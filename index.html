<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>INVENTORY SYSTEM</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- PWA basics + RC icon -->
  <meta name="theme-color" content="#0f172a" />
  <link rel="manifest" href="manifest.json" />
  <link
    rel="icon"
    href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%230f172a'/%3E%3Ctext x='50' y='58' text-anchor='middle' font-size='42' fill='%23ffffff' font-family='system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, sans-serif'%3ERC%3C/text%3E%3C/svg%3E"
  />

  <style>
    :root {
      --bg: #0f172a;
      --card: #020617;
      --border: #1f2937;
      --accent: #4f46e5;
      --accent-soft: #6366f1;
      --danger: #b91c1c;
      --danger-soft: #dc2626;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text-main);
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.7rem 1rem;
      border-bottom: 1px solid var(--border);
      background: #020617;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    header h1 {
      margin: 0;
      font-size: 1.1rem;
      cursor: pointer;
      user-select: none;
    }

    .badge {
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid #4b5563;
      background: #111827;
    }

    .badge-staff {
      border-color: #3b82f6;
      color: #bfdbfe;
    }

    .badge-admin {
      border-color: #22c55e;
      color: #bbf7d0;
    }

    main {
      max-width: 1040px;
      margin: 1rem auto 2rem;
      padding: 0 0.75rem;
    }

    .card {
      background: var(--card);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.9rem 0.9rem 1.1rem;
      margin-bottom: 1rem;
    }

    .card h2 {
      margin: 0 0 0.6rem;
      font-size: 1rem;
    }

    label {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: block;
      margin-bottom: 0.15rem;
    }

    .field-row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0.6rem;
      margin-bottom: 0.6rem;
    }

    input,
    textarea,
    button,
    select {
      font: inherit;
      border-radius: 0.4rem;
      border: 1px solid #374151;
      background: #020617;
      color: var(--text-main);
      padding: 0.4rem 0.55rem;
    }

    input.upper,
    textarea.upper {
      text-transform: uppercase;
    }

    textarea {
      min-height: 50px;
      resize: vertical;
    }

    button {
      cursor: pointer;
      background: var(--accent);
      border-color: var(--accent);
      font-weight: 500;
      font-size: 0.85rem;
    }

    button:hover {
      background: var(--accent-soft);
    }

    button.secondary {
      background: #111827;
      border-color: #4b5563;
    }

    button.secondary:hover {
      background: #1f2937;
    }

    button.danger {
      background: var(--danger);
      border-color: var(--danger);
    }

    button.danger:hover {
      background: var(--danger-soft);
    }

    button.small {
      padding: 0.22rem 0.45rem;
      font-size: 0.7rem;
      margin-right: 0.25rem;
    }

    .actions-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.4rem;
    }

    .actions-row > button {
      flex: 0 0 auto;
    }

    .status {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .muted {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .table-wrapper {
      margin-top: 0.4rem;
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
      text-transform: uppercase;
    }

    th,
    td {
      padding: 0.35rem 0.35rem;
      border-bottom: 1px solid var(--border);
      text-align: left;
      white-space: nowrap;
    }

    th {
      background: #020617;
    }

    tr:hover td {
      background: #020617;
    }

    .batch-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.45rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border);
      margin-bottom: 0.4rem;
      font-size: 0.78rem;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .tab-row {
      display: flex;
      gap: 0.4rem;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
    }

    .tab-btn {
      background: #111827;
      border-color: #4b5563;
      font-size: 0.8rem;
      padding: 0.3rem 0.6rem;
    }

    .tab-btn.active {
      background: var(--accent);
      border-color: var(--accent);
    }

    tr.highlight-row td {
      background: #111827;
      border-bottom-color: var(--accent-soft);
    }

    .name-input-wrapper {
      position: relative;
    }

    .suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #020617;
      border: 1px solid #374151;
      border-radius: 0.4rem;
      margin-top: 0.15rem;
      max-height: 160px;
      overflow-y: auto;
      font-size: 0.75rem;
      display: none;
      z-index: 20;
    }

    .suggestion-item {
      padding: 0.25rem 0.45rem;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .suggestion-item:hover {
      background: #111827;
    }

    .image-thumbs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-top: 0.25rem;
    }

    .image-thumb {
      position: relative;
      width: 70px;
      height: 70px;
      border-radius: 0.4rem;
      overflow: hidden;
      border: 1px solid #374151;
      background: #020617;
    }

    .image-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      cursor: zoom-in;
    }

    .image-thumb button {
      position: absolute;
      top: 2px;
      right: 2px;
      padding: 0 4px;
      font-size: 0.6rem;
      border-radius: 999px;
    }

    #pending-badge.bell-alert {
      border-color: #f97316;
      color: #fecaca;
      box-shadow: 0 0 10px #f97316;
      animation: bellRing 0.9s infinite;
    }

    @keyframes bellRing {
      0% { transform: translateX(0) rotate(0); }
      20% { transform: translateX(-1px) rotate(-5deg); }
      40% { transform: translateX(1px) rotate(5deg); }
      60% { transform: translateX(-1px) rotate(-5deg); }
      80% { transform: translateX(1px) rotate(0); }
      100% { transform: translateX(0) rotate(0); }
    }

    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
    }

    .modal {
      background: var(--card);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.9rem 1rem 1rem;
      width: 100%;
      max-width: 480px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
    }

    .modal h3 {
      margin: 0 0 0.6rem;
      font-size: 0.95rem;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 0.4rem;
      margin-top: 0.6rem;
    }

    /* IMAGE VIEWER */
    #image-viewer {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 70;
      color: #e5e7eb;
    }

    .image-viewer-inner {
      position: relative;
      width: 100%;
      height: 100%;
      max-width: 100vw;
      max-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0.5rem;
      box-sizing: border-box;
    }

    .viewer-top-row {
      width: 100%;
      display: flex;
      justify-content: flex-end;
      margin-bottom: 0.3rem;
    }

    .viewer-close {
      font-size: 1.1rem;
      line-height: 1;
      padding: 0.25rem 0.6rem;
    }

    .viewer-main {
      flex: 1;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .viewer-nav {
      height: 38px;
      min-width: 38px;
      font-size: 1.2rem;
    }

    .viewer-image-wrapper {
      position: relative;
      flex: 1 0 auto;
      width: 90vw;
      max-width: 90vw;
      height: 70vh;
      max-height: 75vh;
      min-height: 40vh;
      overflow: hidden;
      touch-action: none;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #020617;
      border-radius: 0.5rem;
      border: 1px solid #374151;
    }

    #viewer-image {
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      transform-origin: center center;
      user-select: none;
      -webkit-user-drag: none;
      display: block;
    }

    .viewer-footer {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 0.4rem;
      font-size: 0.8rem;
    }

    #viewer-delete-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    @media (max-width: 640px) {
      header {
        gap: 0.5rem;
      }

      header h1 {
        font-size: 1rem;
      }

      .actions-row {
        flex-direction: column;
        align-items: stretch;
      }

      .actions-row > button {
        width: 100%;
      }

      button.small {
        width: 100%;
        margin-right: 0;
      }

      th:nth-child(1),
      td:nth-child(1) {
        display: none;
      }

      td.actions-cell {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .viewer-main {
        gap: 0.25rem;
      }

      .viewer-nav {
        min-width: 32px;
        height: 32px;
      }
    }

    @media (min-width: 641px) {
      .field-row {
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }
    }
  </style>
</head>
<body>
  <header>
    <h1 id="app-title">INVENTORY SYSTEM</h1>
    <span id="role-badge" class="badge badge-staff">STAFF</span>
  </header>

  <main>
    <!-- STAFF ADD + BATCH -->
    <div id="staff-batch-wrapper">
      <!-- ADD / EDIT FORM -->
      <section class="card">
        <h2 id="form-title">ADD ITEM</h2>
        <form id="item-form">
          <div class="field-row">
            <div>
              <label for="item-name">ITEM NAME *</label>
              <div class="name-input-wrapper">
                <input id="item-name" class="upper" autocomplete="off" required />
                <div id="item-suggestions" class="suggestions"></div>
              </div>
            </div>
            <div>
              <label for="item-qty">QUANTITY *</label>
              <input id="item-qty" type="number" min="0" step="1" required />
            </div>
            <div>
              <label for="item-group">GROUP</label>
              <input id="item-group" class="upper" placeholder="E.G. RAW MATERIAL" />
            </div>
          </div>

          <div>
            <label for="item-details">DETAILS</label>
            <textarea id="item-details" class="upper" placeholder="GRADE, BRAND, ETC."></textarea>
          </div>

          <div style="margin-top:0.5rem;">
            <label>IMAGES (REQUIRED, MAX 10, â‰¤ 2MB EACH)</label>
            <div class="actions-row" style="margin-top:0.25rem;">
              <button type="button" id="upload-image-btn" class="secondary small">
                UPLOAD
              </button>
              <button type="button" id="capture-image-btn" class="secondary small">
                CAPTURE
              </button>
              <span class="muted" id="image-status-text"></span>
            </div>
            <input
              id="item-images-upload-input"
              type="file"
              accept="image/*"
              multiple
              style="display:none;"
            />
            <input
              id="item-images-capture-input"
              type="file"
              accept="image/*"
              capture="environment"
              multiple
              style="display:none;"
            />
            <div id="item-images-list">
              <p class="muted">NO IMAGES ADDED.</p>
            </div>
          </div>

          <div class="actions-row" style="margin-top:0.6rem;">
            <button type="submit" id="submit-btn">ADD TO BATCH</button>
            <button type="button" id="cancel-edit-btn" class="secondary" style="display:none;">CANCEL</button>
            <div class="status">STATUS: <span id="status-text">IDLE</span></div>
          </div>
        </form>
      </section>

      <!-- CURRENT BATCH -->
      <section class="card">
        <h2>CURRENT BATCH (NOT UPLOADED)</h2>
        <p class="muted" id="batch-info">
          ADD ITEMS ABOVE. THEY WILL APPEAR HERE UNTIL YOU UPLOAD THE BATCH.
        </p>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>ID</th>
                <th>NAME</th>
                <th>QTY</th>
                <th>GROUP</th>
                <th>DETAILS</th>
                <th>ACTIONS</th>
              </tr>
            </thead>
            <tbody id="batch-body"></tbody>
          </table>
        </div>
        <div class="actions-row" style="margin-top:0.6rem;">
          <button type="button" id="upload-batch-btn" class="secondary">UPLOAD BATCH</button>
          <span class="muted" id="batch-status"></span>
        </div>
      </section>
    </div>

    <!-- ADMIN PANEL -->
    <section class="card" id="admin-card" style="display:none;">
      <h2>
        ADMIN PANEL
        <span id="pending-badge" class="badge">ðŸ”” 0</span>
      </h2>

      <div class="tab-row">
        <button type="button" class="tab-btn admin-main-tab" data-tab="add">ADD ITEMS</button>
        <button type="button" class="tab-btn admin-main-tab active" data-tab="batches">BATCHES</button>
        <button type="button" class="tab-btn admin-main-tab" data-tab="items">ALL ITEMS</button>
      </div>

      <div id="admin-add-tab" style="display:none;">
        <div id="admin-add-container"></div>
      </div>

      <div id="admin-batches-tab">
        <div class="tab-row" id="batch-status-tabs" style="margin-bottom:0.4rem;">
          <button type="button" class="tab-btn small batch-filter-tab active" data-batch-view="pending">PENDING</button>
          <button type="button" class="tab-btn small batch-filter-tab" data-batch-view="approved">APPROVED</button>
          <button type="button" class="tab-btn small batch-filter-tab" data-batch-view="rejected">REJECTED</button>
        </div>

        <div id="batch-items-wrapper" style="margin-top:0.3rem; display:none;">
          <div class="actions-row" style="margin-bottom:0.3rem;">
            <span class="muted" id="selected-batch-label">NO BATCH SELECTED.</span>
            <button type="button" id="approve-batch-btn" class="secondary">
              APPROVE
            </button>
            <button type="button" id="reject-batch-btn" class="danger">
              REJECT
            </button>
            <button type="button" id="send-whatsapp-btn" class="secondary">
              SEND WHATSAPP
            </button>
          </div>
          <div class="table-wrapper">
            <table>
              <thead>
                <tr>
                  <th>ID</th>
                  <th>NAME</th>
                  <th>QTY</th>
                  <th>GROUP</th>
                  <th>DETAILS</th>
                  <th>UPDATED AT</th>
                  <th>ACTIONS</th>
                </tr>
              </thead>
              <tbody id="admin-batch-body"></tbody>
            </table>
          </div>
        </div>

        <div class="muted" id="batch-list-info" style="margin-top:0.6rem;">LOADINGâ€¦</div>

        <div class="field-row" style="margin:0.4rem 0;">
          <div>
            <label for="batch-search-name">SEARCH BATCH BY NAME</label>
            <input id="batch-search-name" placeholder="TYPE BATCH NAMEâ€¦" />
          </div>
          <div>
            <label for="batch-search-date">SEARCH BATCH BY DATE</label>
            <input id="batch-search-date" type="date" />
          </div>
        </div>
        <div class="actions-row" style="margin-top:0.2rem;">
          <button type="button" id="batch-search-btn" class="secondary small">SEARCH</button>
          <button type="button" id="batch-clear-search-btn" class="secondary small">CLEAR</button>
        </div>

        <div id="batch-list" style="margin-top:0.4rem;"></div>
      </div>

      <div id="admin-items-tab" style="display:none;">
        <div class="muted" id="count-info">LOADINGâ€¦</div>

        <div class="field-row" style="margin-top:0.4rem;">
          <div>
            <label for="item-search-input">ITEM NAME</label>
            <input id="item-search-input" placeholder="TYPE ITEM NAMEâ€¦" class="upper" />
          </div>
          <div>
            <label for="report-date-from">DATE FROM (BATCH)</label>
            <input id="report-date-from" type="date" />
          </div>
          <div>
            <label for="report-date-to">DATE TO (BATCH)</label>
            <input id="report-date-to" type="date" />
          </div>
        </div>

        <div class="field-row" style="margin-top:0.4rem;">
          <div>
            <label for="report-group">GROUP</label>
            <input id="report-group" class="upper" placeholder="E.G. RAW MATERIAL" />
          </div>
          <div>
            <label for="report-status">STATUS</label>
            <select id="report-status">
              <option value="ALL">ALL</option>
              <option value="PENDING">PENDING</option>
              <option value="APPROVED">APPROVED</option>
              <option value="REJECTED">REJECTED</option>
            </select>
          </div>
          <div>
            <label for="report-batch">BATCH NAME</label>
            <input id="report-batch" class="upper" placeholder="TYPE BATCH NAMEâ€¦" />
          </div>
        </div>

        <div class="actions-row" style="margin-top:0.2rem;">
          <button type="button" id="item-search-btn" class="secondary small">APPLY FILTERS</button>
          <button type="button" id="item-clear-search-btn" class="secondary small">CLEAR FILTERS</button>
          <span class="muted" id="item-search-result"></span>
        </div>

        <div class="table-wrapper" style="margin-top:0.4rem;">
          <table>
            <thead>
              <tr>
                <th>ID</th>
                <th>NAME</th>
                <th>QTY</th>
                <th>GROUP</th>
                <th>DETAILS</th>
                <th>BATCH TIME</th>
                <th>UPDATED AT</th>
                <th>ACTIONS</th>
              </tr>
            </thead>
            <tbody id="inventory-body"></tbody>
          </table>
        </div>
      </div>
    </section>
  </main>

  <!-- EDIT MODAL -->
  <div id="edit-modal" class="modal-overlay">
    <div class="modal">
      <h3>EDIT ITEM</h3>
      <div class="field-row" style="margin-bottom:0.4rem;">
        <div>
          <label for="modal-name">ITEM NAME *</label>
          <input id="modal-name" class="upper" />
        </div>
        <div>
          <label for="modal-qty">QTY *</label>
          <input id="modal-qty" type="number" min="0" step="1" />
        </div>
      </div>
      <div class="field-row" style="margin-bottom:0.4rem;">
        <div>
          <label for="modal-group">GROUP</label>
          <input id="modal-group" class="upper" />
        </div>
      </div>
      <div>
        <label for="modal-details">DETAILS</label>
        <textarea id="modal-details" class="upper"></textarea>
      </div>

      <div style="margin-top:0.6rem;">
        <label>IMAGES (ADMIN CAN ADD / REMOVE)</label>
        <div class="actions-row" style="margin-top:0.25rem;">
          <button type="button" id="modal-upload-btn" class="secondary small">UPLOAD</button>
          <button type="button" id="modal-capture-btn" class="secondary small">CAPTURE</button>
          <span class="muted" id="modal-image-status"></span>
        </div>
        <input
          id="modal-upload-input"
          type="file"
          accept="image/*"
          multiple
          style="display:none;"
        />
        <input
          id="modal-capture-input"
          type="file"
          accept="image/*"
          capture="environment"
          multiple
          style="display:none;"
        />
        <div id="modal-images-list">
          <p class="muted">NO IMAGES.</p>
        </div>
      </div>

      <div class="modal-footer">
        <button type="button" id="modal-cancel-btn" class="secondary small">CANCEL</button>
        <button type="button" id="modal-save-btn" class="small">SAVE</button>
      </div>
    </div>
  </div>

  <!-- IMAGE VIEWER -->
  <div id="image-viewer">
    <div class="image-viewer-inner">
      <div class="viewer-top-row">
        <button type="button" id="viewer-close-btn" class="secondary small viewer-close">&times;</button>
      </div>
      <div class="viewer-main">
        <button type="button" id="viewer-prev-btn" class="secondary small viewer-nav">&#8249;</button>
        <div class="viewer-image-wrapper" id="viewer-wrapper">
          <img id="viewer-image" src="" alt="IMAGE" />
        </div>
        <button type="button" id="viewer-next-btn" class="secondary small viewer-nav">&#8250;</button>
      </div>
      <div class="viewer-footer">
        <span id="viewer-counter" class="muted"></span>
        <button type="button" id="viewer-delete-btn" class="danger small">DELETE (X)</button>
      </div>
    </div>
  </div>

  <script>
    const BACKEND_URL = "https://inventory-backend-s4sv.onrender.com/get-token";
    const NOTIFY_URL = "https://inventory-backend-s4sv.onrender.com/notify-batch";
    const REPO_OWNER = "unique205";
    const REPO_NAME = "inventory-data";
    const FILE_PATH = "data/inventory.json";
    const IMAGES_FILE_PATH = "images.json";
    const BRANCH = "main";
    const ADMIN_PASSWORD = "admin123";
    const ADMIN_PHONE = "917588756668";
    const WHATSAPP_PHONE = ADMIN_PHONE;

    let currentRole = "staff";
    let inventory = [];
    let currentSha = null;
    let batchItems = [];
    let batchEditIndex = null;
    let adminEditId = null;
    let selectedBatchKey = null;

    let imagesStore = [];
    let imagesSha = null;
    let formImages = [];
    let modalImages = [];

    let batchSearchName = "";
    let batchSearchDate = "";
    let itemSearchTerm = "";
    let currentBatchFilter = "pending";
    let reportDateFrom = "";
    let reportDateTo = "";
    let reportGroupFilter = "";
    let reportStatusFilter = "ALL";
    let reportBatchNameFilter = "";

    let modalEditId = null;

    const viewerState = {
      source: null,
      images: [],
      index: 0,
      deletable: false,
      onChange: null
    };

    const appTitle = document.getElementById("app-title");
    const roleBadge = document.getElementById("role-badge");
    const mainEl = document.querySelector("main");
    const staffBatchWrapper = document.getElementById("staff-batch-wrapper");

    const itemForm = document.getElementById("item-form");
    const itemNameInput = document.getElementById("item-name");
    const itemQtyInput = document.getElementById("item-qty");
    const itemGroupInput = document.getElementById("item-group");
    const itemDetailsInput = document.getElementById("item-details");
    const submitBtn = document.getElementById("submit-btn");
    const cancelEditBtn = document.getElementById("cancel-edit-btn");
    const formTitle = document.getElementById("form-title");
    const statusText = document.getElementById("status-text");

    const nameInputWrapper = document.querySelector(".name-input-wrapper");
    const itemSuggestions = document.getElementById("item-suggestions");

    const uploadImageBtn = document.getElementById("upload-image-btn");
    const captureImageBtn = document.getElementById("capture-image-btn");
    const uploadImageInput = document.getElementById("item-images-upload-input");
    const captureImageInput = document.getElementById("item-images-capture-input");
    const imageList = document.getElementById("item-images-list");
    const imageStatusText = document.getElementById("image-status-text");

    const batchBody = document.getElementById("batch-body");
    const uploadBatchBtn = document.getElementById("upload-batch-btn");
    const batchStatus = document.getElementById("batch-status");

    const adminCard = document.getElementById("admin-card");
    const pendingBadge = document.getElementById("pending-badge");
    const adminAddTab = document.getElementById("admin-add-tab");
    const adminAddContainer = document.getElementById("admin-add-container");
    const adminBatchesTab = document.getElementById("admin-batches-tab");
    const adminItemsTab = document.getElementById("admin-items-tab");
    const tabButtons = document.querySelectorAll(".admin-main-tab");

    const batchListInfo = document.getElementById("batch-list-info");
    const batchList = document.getElementById("batch-list");
    const batchItemsWrapper = document.getElementById("batch-items-wrapper");
    const selectedBatchLabel = document.getElementById("selected-batch-label");
    const approveBatchBtn = document.getElementById("approve-batch-btn");
    const rejectBatchBtn = document.getElementById("reject-batch-btn");
    const sendWhatsAppBtn = document.getElementById("send-whatsapp-btn");
    const adminBatchBody = document.getElementById("admin-batch-body");
    const batchSearchNameInput = document.getElementById("batch-search-name");
    const batchSearchDateInput = document.getElementById("batch-search-date");
    const batchSearchBtn = document.getElementById("batch-search-btn");
    const batchClearSearchBtn = document.getElementById("batch-clear-search-btn");
    const batchFilterButtons = document.querySelectorAll(".batch-filter-tab");

    const countInfo = document.getElementById("count-info");
    const inventoryBody = document.getElementById("inventory-body");
    const itemSearchInput = document.getElementById("item-search-input");
    const itemSearchBtn = document.getElementById("item-search-btn");
    const itemClearSearchBtn = document.getElementById("item-clear-search-btn");
    const itemSearchResult = document.getElementById("item-search-result");
    const reportDateFromInput = document.getElementById("report-date-from");
    const reportDateToInput = document.getElementById("report-date-to");
    const reportGroupInput = document.getElementById("report-group");
    const reportStatusSelect = document.getElementById("report-status");
    const reportBatchInput = document.getElementById("report-batch");

    const editModal = document.getElementById("edit-modal");
    const modalNameInput = document.getElementById("modal-name");
    const modalQtyInput = document.getElementById("modal-qty");
    const modalGroupInput = document.getElementById("modal-group");
    const modalDetailsInput = document.getElementById("modal-details");
    const modalCancelBtn = document.getElementById("modal-cancel-btn");
    const modalSaveBtn = document.getElementById("modal-save-btn");
    const modalUploadBtn = document.getElementById("modal-upload-btn");
    const modalCaptureBtn = document.getElementById("modal-capture-btn");
    const modalUploadInput = document.getElementById("modal-upload-input");
    const modalCaptureInput = document.getElementById("modal-capture-input");
    const modalImagesList = document.getElementById("modal-images-list");
    const modalImageStatus = document.getElementById("modal-image-status");

    const imageViewer = document.getElementById("image-viewer");
    const viewerCloseBtn = document.getElementById("viewer-close-btn");
    const viewerPrevBtn = document.getElementById("viewer-prev-btn");
    const viewerNextBtn = document.getElementById("viewer-next-btn");
    const viewerDeleteBtn = document.getElementById("viewer-delete-btn");
    const viewerImage = document.getElementById("viewer-image");
    const viewerCounter = document.getElementById("viewer-counter");
    const viewerWrapper = document.getElementById("viewer-wrapper");

    function setStatus(msg) {
      statusText.textContent = msg.toUpperCase();
    }

    function generateId() {
      const ts = Date.now();
      const rand = Math.random().toString(36).substring(2, 8);
      return `ITEM_${ts}_${rand.toUpperCase()}`;
    }

    function generateBatchId() {
      const ts = Date.now();
      const rand = Math.random().toString(36).substring(2, 8).toUpperCase();
      return `BATCH_${ts}_${rand}`;
    }

    function generateImageId() {
      const ts = Date.now();
      const rand = Math.random().toString(36).substring(2, 6).toUpperCase();
      return `IMG_${ts}_${rand}`;
    }

    function formatDate(iso) {
      if (!iso) return "-";
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return String(iso).toUpperCase();
      return d.toLocaleString().toUpperCase();
    }

    function getBatchKeyForItem(item) {
      return item.batchId || item.batchTime || item.timestamp || "UNKNOWN";
    }

    function getBatchTimeForItem(item) {
      return item.batchTime || item.timestamp || null;
    }

    function getStatusDisplay(statusRaw) {
      const s = (statusRaw || "PENDING").toUpperCase();
      if (s === "APPROVED") return "âœ… APPROVED";
      if (s === "REJECTED") return "âŒ REJECTED";
      return "ðŸŸ¡ PENDING";
    }

    async function getBackendToken() {
      try {
        const res = await fetch(BACKEND_URL, { method: "POST" });
        if (!res.ok) return null;
        const data = await res.json().catch(() => ({}));
        return data.token || null;
      } catch {
        return null;
      }
    }

    async function githubRequest(path, options = {}) {
      const token = await getBackendToken();
      if (!token) throw new Error("BACKEND TOKEN REQUEST FAILED");

      const res = await fetch(`https://api.github.com${path}`, {
        ...options,
        headers: {
          "Authorization": `Bearer ${token}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json",
          ...(options.headers || {})
        }
      });

      if (!res.ok) {
        const text = await res.text();
        throw new Error(`GITHUB ERROR ${res.status}: ${text}`);
      }
      return res.json();
    }

    function resetForm() {
      itemNameInput.value = "";
      itemQtyInput.value = "";
      itemGroupInput.value = "";
      itemDetailsInput.value = "";
      batchEditIndex = null;
      adminEditId = null;
      formImages = [];
      renderFormImages();

      submitBtn.textContent = "ADD TO BATCH";
      formTitle.textContent = currentRole === "admin" ? "ADD ITEM (ADMIN)" : "ADD ITEM";
      cancelEditBtn.style.display = "none";
    }

    function moveStaffUIForRole() {
      if (!staffBatchWrapper || !adminCard || !mainEl || !adminAddContainer) return;
      if (currentRole === "admin") {
        if (staffBatchWrapper.parentNode !== adminAddContainer) {
          adminAddContainer.appendChild(staffBatchWrapper);
        }
      } else {
        if (staffBatchWrapper.parentNode !== mainEl) {
          mainEl.insertBefore(staffBatchWrapper, adminCard);
        }
      }
    }

    function setAdminMainTab(tab) {
      tabButtons.forEach((b) => {
        b.classList.toggle("active", b.dataset.tab === tab);
      });
      adminAddTab.style.display = tab === "add" ? "block" : "none";
      adminBatchesTab.style.display = tab === "batches" ? "block" : "none";
      adminItemsTab.style.display = tab === "items" ? "block" : "none";
    }

    function updateRoleUI() {
      moveStaffUIForRole();

      if (currentRole === "admin") {
        roleBadge.textContent = "ADMIN";
        roleBadge.className = "badge badge-admin";
        adminCard.style.display = "block";
        setAdminMainTab("batches");
      } else {
        roleBadge.textContent = "STAFF";
        roleBadge.className = "badge badge-staff";
        adminCard.style.display = "none";
      }
      renderBatch();
      renderAdminViews();
    }

    function playBellSound() {
      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const ctx = new AudioContext();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = "sine";
        osc.frequency.value = 880;
        osc.connect(gain);
        gain.connect(ctx.destination);
        gain.gain.value = 0.1;
        const now = ctx.currentTime;
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
        osc.start(now);
        osc.stop(now + 0.6);
      } catch {}
    }

    async function loadInventory() {
      try {
        setStatus("LOADING FROM GITHUBâ€¦");
        const data = await githubRequest(
          `/repos/${REPO_OWNER}/${REPO_NAME}/contents/${encodeURIComponent(FILE_PATH)}?ref=${BRANCH}`
        );
        currentSha = data.sha;
        const decoded = atob(data.content.replace(/\n/g, ""));
        inventory = decoded.trim() ? JSON.parse(decoded) : [];
        renderAdminViews();
        setStatus("LOADED");
      } catch (err) {
        console.error("ERROR LOADING INVENTORY:", err);
        inventory = [];
        currentSha = null;
        renderAdminViews();
        setStatus("WORKING OFFLINE");
      }
    }

    async function saveInventory() {
      const snapshot = JSON.stringify(inventory, null, 2);
      const content = btoa(snapshot);
      const body = {
        message: "UPDATE INVENTORY.JSON FROM INVENTORY-APP",
        content,
        branch: BRANCH
      };
      if (currentSha) body.sha = currentSha;

      const data = await githubRequest(
        `/repos/${REPO_OWNER}/${REPO_NAME}/contents/${encodeURIComponent(FILE_PATH)}`,
        { method: "PUT", body: JSON.stringify(body) }
      );
      currentSha = data.content.sha;
    }

    async function loadImages() {
      try {
        const data = await githubRequest(
          `/repos/${REPO_OWNER}/${REPO_NAME}/contents/${encodeURIComponent(IMAGES_FILE_PATH)}?ref=${BRANCH}`
        );
        imagesSha = data.sha;
        const decoded = atob(data.content.replace(/\n/g, ""));
        imagesStore = decoded.trim() ? JSON.parse(decoded) : [];
      } catch (err) {
        console.warn("LOAD IMAGES FAILED:", err);
        imagesStore = [];
        imagesSha = null;
      }
    }

    async function saveImages() {
      const snapshot = JSON.stringify(imagesStore, null, 2);
      const content = btoa(snapshot);
      const body = {
        message: "UPDATE IMAGES.JSON FROM INVENTORY-APP",
        content,
        branch: BRANCH
      };
      if (imagesSha) body.sha = imagesSha;

      const data = await githubRequest(
        `/repos/${REPO_OWNER}/${REPO_NAME}/contents/${encodeURIComponent(IMAGES_FILE_PATH)}`,
        { method: "PUT", body: JSON.stringify(body) }
      );
      imagesSha = data.content.sha;
    }

    function getImagesForItem(itemId) {
      const entry = imagesStore.find((e) => e.itemId === itemId);
      return entry ? entry.images || [] : [];
    }

    function setImagesForItem(itemId, images) {
      const idx = imagesStore.findIndex((e) => e.itemId === itemId);
      const payload = { itemId, images };
      if (idx === -1) imagesStore.push(payload);
      else imagesStore[idx] = payload;
    }

    function renderBatch() {
      batchBody.innerHTML = "";

      if (!batchItems.length) {
        batchBody.innerHTML =
          '<tr><td colspan="6" class="muted">NO ITEMS IN BATCH.</td></tr>';
        return;
      }

      batchItems.forEach((item, index) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${item.id}</td>
          <td>${item.name}</td>
          <td>${item.quantity}</td>
          <td>${item.group || ""}</td>
          <td>${item.details || ""}</td>
          <td class="actions-cell">
            <button class="small secondary" data-action="edit-batch" data-index="${index}">EDIT</button>
            <button class="small danger" data-action="remove-batch" data-index="${index}">REMOVE</button>
          </td>`;
        batchBody.appendChild(tr);
      });
    }

    batchBody.addEventListener("click", (e) => {
      const btn = e.target;
      if (!btn.dataset.action) return;
      const idx = Number(btn.dataset.index);

      if (btn.dataset.action === "edit-batch") {
        const item = batchItems[idx];
        batchEditIndex = idx;
        itemNameInput.value = item.name;
        itemQtyInput.value = item.quantity;
        itemGroupInput.value = item.group || "";
        itemDetailsInput.value = item.details || "";
        formImages = (item.images || []).map((img) => ({ ...img }));
        renderFormImages();

        submitBtn.textContent = "UPDATE BATCH ITEM";
        cancelEditBtn.style.display = "inline-block";
        formTitle.textContent = currentRole === "admin" ? "EDIT ITEM (ADMIN)" : "EDIT BATCH ITEM";
        window.scrollTo({ top: 0, behavior: "smooth" });
      } else if (btn.dataset.action === "remove-batch") {
        batchItems.splice(idx, 1);
        renderBatch();
      }
    });

    uploadBatchBtn.addEventListener("click", async () => {
      if (!batchItems.length) {
        batchStatus.textContent = "NO ITEMS IN BATCH.";
        return;
      }

      try {
        setStatus("UPLOADING BATCHâ€¦");
        batchStatus.textContent = "UPLOADINGâ€¦";

        const batchTime = new Date().toISOString();
        const batchId = generateBatchId();

        await loadInventory();
        await loadImages();

        const enriched = batchItems.map((item) => ({
          ...item,
          batchId,
          batchTime,
          batchStatus: "PENDING",
          batchName: item.batchName || ""
        }));

        inventory = inventory.concat(enriched);

        enriched.forEach((item) => {
          const imgs = item.images || [];
          setImagesForItem(item.id, imgs);
        });

        await saveInventory();
        await saveImages();
        await loadInventory();
        await loadImages();

        batchItems = [];
        renderBatch();
        batchStatus.textContent =
          "BATCH UPLOADED AT " + formatDate(batchTime);
        setStatus("BATCH UPLOADED");
      } catch (err) {
        console.error("BATCH UPLOAD FAILED:", err);
        batchStatus.textContent = "ERROR UPLOADING BATCH.";
        setStatus("ERROR UPLOADING");
      }
    });

    function renderFormImages() {
      if (!imageList) return;
      if (!formImages.length) {
        imageList.innerHTML = '<p class="muted">NO IMAGES ADDED.</p>';
        imageStatusText.textContent = "";
        return;
      }

      const wrap = document.createElement("div");
      wrap.className = "image-thumbs";
      formImages.forEach((img, index) => {
        const div = document.createElement("div");
        div.className = "image-thumb";
        div.innerHTML = `
          <img src="${img.dataUrl}" alt="" data-view-source="form" data-view-index="${index}">
          <button type="button" class="danger small" data-img-id="${img.id}">X</button>
        `;
        wrap.appendChild(div);
      });
      imageList.innerHTML = "";
      imageList.appendChild(wrap);
      imageStatusText.textContent = `${formImages.length} IMAGE(S)`;
    }

    uploadImageBtn.addEventListener("click", () => {
      uploadImageInput.click();
    });

    captureImageBtn.addEventListener("click", () => {
      captureImageInput.click();
    });

    async function compressImageFile(file, maxSizeBytes) {
      const dataUrl = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            const maxDim = 1280;
            let width = img.width;
            let height = img.height;

            if (width > height && width > maxDim) {
              height = Math.round((height * maxDim) / width);
              width = maxDim;
            } else if (height >= width && height > maxDim) {
              width = Math.round((width * maxDim) / height);
              height = maxDim;
            }

            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);

            let quality = 0.9;
            let out = canvas.toDataURL("image/jpeg", quality);

            const calcSize = (d) => Math.round((d.length * 3) / 4);

            while (calcSize(out) > maxSizeBytes && quality > 0.3) {
              quality -= 0.1;
              out = canvas.toDataURL("image/jpeg", quality);
            }

            if (calcSize(out) > maxSizeBytes) {
              resolve(null);
            } else {
              resolve(out);
            }
          };
          img.onerror = reject;
          img.src = e.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      }).catch(() => null);

      if (!dataUrl) return null;

      return {
        id: generateImageId(),
        name: file.name,
        size: Math.round((dataUrl.length * 3) / 4),
        dataUrl
      };
    }

    async function processSelectedFiles(files, targetArray, statusEl, renderFn) {
      if (!files.length) return;

      const maxImages = 10;
      const maxSize = 2 * 1024 * 1024;
      let rejectedTooMany = false;
      let rejectedSize = false;

      for (const file of files) {
        if (targetArray.length >= maxImages) {
          rejectedTooMany = true;
          break;
        }

        const compressed = await compressImageFile(file, maxSize);
        if (!compressed) {
          rejectedSize = true;
          continue;
        }

        targetArray.push(compressed);
      }

      renderFn();

      if (statusEl) {
        if (rejectedTooMany) {
          statusEl.textContent = "MAX 10 IMAGES REACHED.";
        } else if (rejectedSize) {
          statusEl.textContent = "SOME IMAGES COULD NOT BE COMPRESSED <= 2MB.";
        } else {
          statusEl.textContent = `${targetArray.length} IMAGE(S)`;
        }
      }
    }

    uploadImageInput.addEventListener("change", (e) => {
      const files = Array.from(e.target.files || []);
      processSelectedFiles(files, formImages, imageStatusText, renderFormImages);
      uploadImageInput.value = "";
    });

    captureImageInput.addEventListener("change", (e) => {
      const files = Array.from(e.target.files || []);
      processSelectedFiles(files, formImages, imageStatusText, renderFormImages);
      captureImageInput.value = "";
    });

    imageList.addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-img-id]");
      if (!btn) return;
      const id = btn.dataset.imgId;
      formImages = formImages.filter((img) => img.id !== id);
      renderFormImages();
    });

    function clearSuggestions() {
      if (!itemSuggestions) return;
      itemSuggestions.innerHTML = "";
      itemSuggestions.style.display = "none";
    }

    function showItemSuggestions(term) {
      if (!itemSuggestions) return;
      const query = term.trim().toUpperCase();
      if (!query) {
        clearSuggestions();
        return;
      }

      const byName = new Map();
      inventory.forEach((it) => {
        const n = (it.name || "").toString().toUpperCase();
        if (!n) return;
        if (!byName.has(n)) byName.set(n, it);
      });

      const matches = [];
      byName.forEach((it, n) => {
        if (n.includes(query)) matches.push(it);
      });

      matches.sort((a, b) => {
        const na = (a.name || "").toString();
        const nb = (b.name || "").toString();
        return na.localeCompare(nb);
      });

      if (!matches.length) {
        clearSuggestions();
        return;
      }

      const limited = matches.slice(0, 8);
      itemSuggestions.innerHTML = "";
      limited.forEach((it) => {
        const div = document.createElement("div");
        div.className = "suggestion-item";
        div.dataset.name = (it.name || "").toString().toUpperCase();
        div.textContent = it.name || "";
        itemSuggestions.appendChild(div);
      });
      itemSuggestions.style.display = "block";
    }

    itemNameInput.addEventListener("input", () => {
      showItemSuggestions(itemNameInput.value);
    });

    itemSuggestions.addEventListener("click", (e) => {
      const target = e.target.closest(".suggestion-item");
      if (!target) return;
      const nameUpper = target.dataset.name || "";
      const match = inventory.find(
        (it) => (it.name || "").toString().toUpperCase() === nameUpper
      );
      if (!match) return;

      itemNameInput.value = (match.name || "").toString().toUpperCase();
      if (match.quantity != null) itemQtyInput.value = match.quantity;
      itemGroupInput.value = (match.group || "").toString().toUpperCase();
      itemDetailsInput.value = (match.details || "").toString().toUpperCase();
      formImages = getImagesForItem(match.id).map((img) => ({ ...img }));
      renderFormImages();
      clearSuggestions();
    });

    document.addEventListener("click", (e) => {
      if (nameInputWrapper && !nameInputWrapper.contains(e.target)) {
        clearSuggestions();
      }
    });

    function groupByBatch() {
      const groups = {};
      inventory.forEach((item) => {
        const key = getBatchKeyForItem(item);
        if (!groups[key]) groups[key] = [];
        groups[key].push(item);
      });
      return groups;
    }

    function renderAdminViews() {
      if (currentRole !== "admin") return;

      const groups = groupByBatch();
      const keys = Object.keys(groups).sort((a, b) => {
        const ia = groups[a][0];
        const ib = groups[b][0];
        const ta = getBatchTimeForItem(ia) || "";
        const tb = getBatchTimeForItem(ib) || "";
        const da = new Date(ta);
        const db = new Date(tb);
        if (isNaN(da) || isNaN(db)) return 0;
        return db - da;
      });

      let pendingCount = 0;
      let approvedCount = 0;
      let rejectedCount = 0;
      keys.forEach((k) => {
        const first = groups[k][0];
        const statusRaw = (first.batchStatus || "PENDING").toUpperCase();
        if (statusRaw === "APPROVED") approvedCount++;
        else if (statusRaw === "REJECTED") rejectedCount++;
        else pendingCount++;
      });

      if (pendingBadge) {
        pendingBadge.textContent = `ðŸ”” ${pendingCount}`;
        if (pendingCount > 0) pendingBadge.classList.add("bell-alert");
        else pendingBadge.classList.remove("bell-alert");
      }

      batchList.innerHTML = "";
      let shownCount = 0;

      keys.forEach((k) => {
        const items = groups[k];
        const first = items[0];
        const batchTime = getBatchTimeForItem(first) || k;
        const batchName = (first.batchName || "").trim();
        const displayName = batchName || formatDate(batchTime);
        const statusRaw = (first.batchStatus || "PENDING").toUpperCase();
        const statusDisplay = getStatusDisplay(statusRaw);

        if (currentBatchFilter === "pending" && statusRaw !== "PENDING") return;
        if (currentBatchFilter === "approved" && statusRaw !== "APPROVED") return;
        if (currentBatchFilter === "rejected" && statusRaw !== "REJECTED") return;

        const nameFilter = batchSearchName;
        const dateFilter = batchSearchDate;
        const dateStr = (() => {
          const d = new Date(batchTime);
          if (isNaN(d)) return "";
          return d.toISOString().slice(0, 10);
        })();

        if (nameFilter && !displayName.toUpperCase().includes(nameFilter)) return;
        if (dateFilter && dateStr !== dateFilter) return;

        const div = document.createElement("div");
        div.className = "batch-header";
        div.innerHTML = `
          <span>BATCH: ${displayName}</span>
          <span>DATE: ${formatDate(batchTime)}</span>
          <span>ITEMS: ${items.length}</span>
          <span>STATUS: ${statusDisplay}</span>
          <span>
            <button class="small secondary" data-action="view-batch" data-key="${k}">VIEW</button>
            <button class="small secondary" data-action="rename-batch" data-key="${k}">RENAME</button>
          </span>`;
        batchList.appendChild(div);
        shownCount++;
      });

      if (!keys.length) {
        batchListInfo.textContent = "NO BATCHES FOUND.";
      } else {
        batchListInfo.textContent =
          `${pendingCount} PENDING â€¢ ${approvedCount} APPROVED â€¢ ${rejectedCount} REJECTED (VIEW: ${currentBatchFilter.toUpperCase()}, SHOWING ${shownCount})`;
      }

      inventoryBody.innerHTML = "";
      if (!inventory.length) {
        countInfo.textContent = "NO ITEMS IN INVENTORY.";
        inventoryBody.innerHTML =
          '<tr><td colspan="8" class="muted">NO ITEMS.</td></tr>';
        itemSearchResult.textContent = "";
      } else {
        let filteredCount = 0;
        let matchCount = 0;
        let firstMatchInfo = null;

        inventory.forEach((item) => {
          const nameUpper = (item.name || "").toString().toUpperCase();
          const groupUpper = (item.group || "").toString().toUpperCase();
          const statusRaw = (item.batchStatus || "PENDING").toUpperCase();
          const batchNameUpper = (item.batchName || "").toString().toUpperCase();
          const batchKey = getBatchKeyForItem(item);
          const batchTime = getBatchTimeForItem(item) || batchKey;
          const batchDateStr = (() => {
            const d = new Date(batchTime);
            if (isNaN(d)) return "";
            return d.toISOString().slice(0, 10);
          })();

          if (itemSearchTerm && !nameUpper.includes(itemSearchTerm)) return;
          if (reportGroupFilter && !groupUpper.includes(reportGroupFilter)) return;
          if (reportStatusFilter !== "ALL" && statusRaw !== reportStatusFilter) return;
          if (reportBatchNameFilter && !batchNameUpper.includes(reportBatchNameFilter)) return;
          if (reportDateFrom && batchDateStr && batchDateStr < reportDateFrom) return;
          if (reportDateTo && batchDateStr && batchDateStr > reportDateTo) return;

          filteredCount++;

          const matchesName = itemSearchTerm && nameUpper.includes(itemSearchTerm);
          if (matchesName) {
            matchCount++;
            if (!firstMatchInfo) {
              const batchLabel = batchNameUpper
                ? item.batchName
                : formatDate(batchTime);
              const statusDisplay = getStatusDisplay(statusRaw);
              firstMatchInfo = {
                name: item.name,
                batchLabel,
                statusDisplay
              };
            }
          }

          const tr = document.createElement("tr");
          if (matchesName) tr.classList.add("highlight-row");
          tr.innerHTML = `
            <td>${item.id || "-"}</td>
            <td>${item.name || ""}</td>
            <td>${item.quantity ?? ""}</td>
            <td>${item.group || ""}</td>
            <td>${item.details || ""}</td>
            <td>${formatDate(item.batchTime || item.timestamp)}</td>
            <td>${formatDate(item.updatedAt || item.timestamp)}</td>
            <td class="actions-cell">
              <button class="small secondary" data-action="edit-item" data-id="${item.id}">EDIT</button>
              <button class="small danger" data-action="delete-item" data-id="${item.id}">DELETE</button>
            </td>`;
          inventoryBody.appendChild(tr);
        });

        if (!filteredCount) {
          inventoryBody.innerHTML =
            '<tr><td colspan="8" class="muted">NO ITEMS MATCH FILTERS.</td></tr>';
        }

        countInfo.textContent = `${filteredCount} ITEMS (FILTERED FROM ${inventory.length})`;

        if (itemSearchTerm && matchCount > 0 && firstMatchInfo) {
          itemSearchResult.textContent =
            `'${firstMatchInfo.name}' FOUND IN BATCH: ${firstMatchInfo.batchLabel} â€¢ STATUS: ${firstMatchInfo.statusDisplay}`;
        } else if (itemSearchTerm && filteredCount === 0) {
          itemSearchResult.textContent = "NO ITEMS FOUND FOR SEARCH.";
        } else {
          itemSearchResult.textContent = "";
        }
      }

      if (selectedBatchKey && groups[selectedBatchKey]) {
        renderSelectedBatchItems(selectedBatchKey, groups[selectedBatchKey]);
      } else {
        batchItemsWrapper.style.display = "none";
        selectedBatchLabel.textContent = "NO BATCH SELECTED.";
      }
    }

    batchList.addEventListener("click", async (e) => {
      const btn = e.target;
      const action = btn.dataset.action;
      const key = btn.dataset.key;
      if (!action || !key) return;

      const groups = groupByBatch();

      if (action === "view-batch") {
        if (!groups[key]) return;
        selectedBatchKey = key;
        renderSelectedBatchItems(key, groups[key]);
      } else if (action === "rename-batch") {
        if (!groups[key]) return;
        const items = groups[key];
        const currentName = (items[0].batchName || "").trim();
        const newName = prompt("ENTER BATCH NAME:", currentName);
        if (newName === null) return;

        const trimmed = newName.trim().toUpperCase();
        try {
          setStatus("UPDATING BATCH NAMEâ€¦");
          await loadInventory();
          const freshGroups = groupByBatch();
          const freshItems = freshGroups[key] || [];
          freshItems.forEach((it) => {
            it.batchName = trimmed;
          });
          await saveInventory();
          await loadInventory();
          setStatus("BATCH NAME UPDATED");
        } catch (err) {
          console.error("RENAME BATCH FAILED:", err);
          setStatus("ERROR RENAMING BATCH");
        }
      }
    });

    function renderSelectedBatchItems(batchKey, items) {
      batchItemsWrapper.style.display = "block";
      const first = items[0];
      const batchTime = getBatchTimeForItem(first) || batchKey;
      const batchName = (first.batchName || "").trim();
      const displayName = batchName || formatDate(batchTime);
      const statusRaw = first.batchStatus || "PENDING";
      const statusDisplay = getStatusDisplay(statusRaw);

      selectedBatchLabel.textContent = `BATCH: ${displayName} â€¢ DATE: ${formatDate(
        batchTime
      )} â€¢ ${items.length} ITEM(S) â€¢ STATUS: ${statusDisplay}`;

      adminBatchBody.innerHTML = "";
      items.forEach((item) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${item.id || "-"}</td>
          <td>${item.name || ""}</td>
          <td>${item.quantity ?? ""}</td>
          <td>${item.group || ""}</td>
          <td>${item.details || ""}</td>
          <td>${formatDate(item.updatedAt || item.timestamp)}</td>
          <td class="actions-cell">
            <button class="small secondary" data-action="edit-item" data-id="${item.id}">EDIT</button>
            <button class="small danger" data-action="delete-item" data-id="${item.id}">DELETE</button>
          </td>`;
        adminBatchBody.appendChild(tr);
      });
    }

    approveBatchBtn.addEventListener("click", async () => {
      if (!selectedBatchKey) {
        alert("NO BATCH SELECTED.");
        return;
      }

      const groups = groupByBatch();
      const items = groups[selectedBatchKey];
      if (!items || !items.length) {
        alert("BATCH HAS NO ITEMS.");
        return;
      }

      try {
        setStatus("APPROVING BATCHâ€¦");

        inventory.forEach((it) => {
          if (getBatchKeyForItem(it) === selectedBatchKey) it.batchStatus = "APPROVED";
        });
        await saveInventory();
        await loadInventory();

        const freshGroups = groupByBatch();
        const freshItems = freshGroups[selectedBatchKey] || [];
        const payload = {
          phone: ADMIN_PHONE,
          batchTime: getBatchTimeForItem(freshItems[0]) || selectedBatchKey,
          items: freshItems.map((it) => ({
            name: it.name,
            quantity: it.quantity,
            group: it.group,
            details: it.details
          }))
        };

        fetch(NOTIFY_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        }).catch((err) => console.error("NOTIFY FAILED:", err));

        setStatus("BATCH APPROVED");
      } catch (err) {
        console.error("APPROVE FAILED:", err);
        setStatus("ERROR APPROVING BATCH");
      }
    });

    rejectBatchBtn.addEventListener("click", async () => {
      if (!selectedBatchKey) {
        alert("NO BATCH SELECTED.");
        return;
      }

      const groups = groupByBatch();
      const items = groups[selectedBatchKey];
      if (!items || !items.length) {
        alert("BATCH HAS NO ITEMS.");
        return;
      }

      if (!confirm("REJECT THIS BATCH?")) return;

      try {
        setStatus("REJECTING BATCHâ€¦");

        inventory.forEach((it) => {
          if (getBatchKeyForItem(it) === selectedBatchKey) it.batchStatus = "REJECTED";
        });
        await saveInventory();
        await loadInventory();
        setStatus("BATCH REJECTED");
      } catch (err) {
        console.error("REJECT FAILED:", err);
        setStatus("ERROR REJECTING BATCH");
      }
    });

    function buildBatchWhatsAppMessage(items) {
      const lines = items.map((it) => {
        const parts = [
          (it.name || "").toString().toUpperCase(),
          String(it.quantity ?? ""),
          (it.group || "").toString().toUpperCase()
        ];
        return parts.join(", ");
      });
      return lines.join("\n");
    }

    function openWhatsAppForBatch(message) {
      const url = `https://wa.me/${WHATSAPP_PHONE}?text=${encodeURIComponent(message)}`;
      try {
        const win = window.open(url, "_blank");
        return !!win;
      } catch {
        return false;
      }
    }

    sendWhatsAppBtn.addEventListener("click", () => {
      if (!selectedBatchKey) {
        alert("NO BATCH SELECTED.");
        return;
      }

      const groups = groupByBatch();
      const items = groups[selectedBatchKey];
      if (!items || !items.length) {
        alert("BATCH HAS NO ITEMS.");
        return;
      }

      const first = items[0];
      const statusRaw = (first.batchStatus || "PENDING").toUpperCase();
      if (statusRaw !== "APPROVED") {
        alert("BATCH IS NOT APPROVED YET.");
        return;
      }

      const message = buildBatchWhatsAppMessage(items);
      const opened = openWhatsAppForBatch(message);
      if (!opened) alert("WHATSAPP MESSAGE (COPY & SEND):\n\n" + message);
    });

    function renderModalImages() {
      if (!modalImagesList) return;
      if (!modalImages.length) {
        modalImagesList.innerHTML = '<p class="muted">NO IMAGES.</p>';
        modalImageStatus.textContent = "";
        return;
      }

      const wrap = document.createElement("div");
      wrap.className = "image-thumbs";
      modalImages.forEach((img, index) => {
        const div = document.createElement("div");
        div.className = "image-thumb";
        div.innerHTML = `
          <img src="${img.dataUrl}" alt="" data-view-source="modal" data-view-index="${index}">
          <button type="button" class="danger small" data-modal-img-id="${img.id}">X</button>
        `;
        wrap.appendChild(div);
      });
      modalImagesList.innerHTML = "";
      modalImagesList.appendChild(wrap);
      modalImageStatus.textContent = `${modalImages.length} IMAGE(S)`;
    }

    function openEditModal(item) {
      modalEditId = item.id;
      modalNameInput.value = (item.name || "").toString().toUpperCase();
      modalQtyInput.value = item.quantity ?? "";
      modalGroupInput.value = (item.group || "").toString().toUpperCase();
      modalDetailsInput.value = (item.details || "").toString().toUpperCase();
      modalImages = getImagesForItem(item.id).map((img) => ({ ...img }));
      renderModalImages();
      editModal.style.display = "flex";
    }

    function closeEditModal() {
      modalEditId = null;
      editModal.style.display = "none";
    }

    modalCancelBtn.addEventListener("click", () => {
      closeEditModal();
    });

    editModal.addEventListener("click", (e) => {
      if (e.target === editModal) {
        closeEditModal();
      }
    });

    modalUploadBtn.addEventListener("click", () => {
      modalUploadInput.click();
    });

    modalCaptureBtn.addEventListener("click", () => {
      modalCaptureInput.click();
    });

    modalUploadInput.addEventListener("change", (e) => {
      const files = Array.from(e.target.files || []);
      processSelectedFiles(files, modalImages, modalImageStatus, renderModalImages);
      modalUploadInput.value = "";
    });

    modalCaptureInput.addEventListener("change", (e) => {
      const files = Array.from(e.target.files || []);
      processSelectedFiles(files, modalImages, modalImageStatus, renderModalImages);
      modalCaptureInput.value = "";
    });

    modalImagesList.addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-modal-img-id]");
      if (!btn) return;
      const id = btn.dataset.modalImgId;
      modalImages = modalImages.filter((img) => img.id !== id);
      renderModalImages();
    });

    modalSaveBtn.addEventListener("click", async () => {
      if (!modalEditId) {
        closeEditModal();
        return;
      }

      const name = modalNameInput.value.trim().toUpperCase();
      const qty = Number(modalQtyInput.value || 0);
      const group = modalGroupInput.value.trim().toUpperCase();
      const details = modalDetailsInput.value.trim().toUpperCase();

      if (!name || Number.isNaN(qty)) {
        alert("NAME AND QUANTITY ARE REQUIRED.");
        return;
      }

      const now = new Date().toISOString();

      try {
        setStatus("UPDATING ITEMâ€¦");
        await loadInventory();
        await loadImages();

        const idx = inventory.findIndex((it) => it.id === modalEditId);
        if (idx === -1) {
          setStatus("ITEM NOT FOUND");
          closeEditModal();
          return;
        }

        inventory[idx] = {
          ...inventory[idx],
          name,
          quantity: qty,
          group,
          details,
          updatedAt: now
        };
        setImagesForItem(modalEditId, modalImages.map((img) => ({ ...img })));

        await saveInventory();
        await saveImages();
        await loadInventory();
        await loadImages();
        closeEditModal();
        setStatus("ITEM UPDATED");
      } catch (err) {
        console.error("MODAL SAVE FAILED:", err);
        setStatus("ERROR SAVING");
      }
    });

    adminBatchBody.addEventListener("click", handleAdminTableClick);
    inventoryBody.addEventListener("click", handleAdminTableClick);

    async function handleAdminTableClick(e) {
      const btn = e.target;
      const id = btn.dataset.id;
      if (!btn.dataset.action || !id) return;

      if (btn.dataset.action === "edit-item") {
        await loadImages();
        const item = inventory.find((it) => it.id === id);
        if (!item) {
          setStatus("ITEM NOT FOUND");
          return;
        }
        openEditModal(item);
      } else if (btn.dataset.action === "delete-item") {
        if (!confirm("DELETE THIS ITEM?")) return;

        try {
          setStatus("DELETING ITEMâ€¦");
          await loadInventory();
          await loadImages();

          const idx = inventory.findIndex((it) => it.id === id);
          if (idx === -1) {
            setStatus("ITEM NOT FOUND");
            return;
          }

          inventory.splice(idx, 1);
          imagesStore = imagesStore.filter((e) => e.itemId !== id);

          await saveInventory();
          await saveImages();
          await loadInventory();
          await loadImages();
          setStatus("ITEM DELETED");
        } catch (err) {
          console.error("DELETE FAILED:", err);
          setStatus("ERROR DELETING");
        }
      }
    }

    itemForm.addEventListener("submit", async (e) => {
      e.preventDefault();

      const name = itemNameInput.value.trim().toUpperCase();
      const qty = Number(itemQtyInput.value || 0);
      const group = itemGroupInput.value.trim().toUpperCase();
      const details = itemDetailsInput.value.trim().toUpperCase();

      if (!name || Number.isNaN(qty)) {
        alert("NAME AND QUANTITY ARE REQUIRED.");
        return;
      }
      if (!formImages.length) {
        alert("AT LEAST 1 IMAGE IS REQUIRED.");
        return;
      }

      const now = new Date().toISOString();

      const baseItem = {
        id:
          batchEditIndex === null
            ? adminEditId || generateId()
            : batchItems[batchEditIndex].id,
        name,
        quantity: qty,
        group,
        details,
        timestamp:
          batchEditIndex === null
            ? now
            : batchItems[batchEditIndex].timestamp || now,
        updatedAt: now
      };

      if (currentRole === "admin" && adminEditId && batchEditIndex === null) {
        try {
          setStatus("UPDATING ITEMâ€¦");
          await loadInventory();
          await loadImages();

          const idx = inventory.findIndex((it) => it.id === adminEditId);
          if (idx === -1) {
            setStatus("ITEM NOT FOUND");
            return;
          }

          inventory[idx] = {
            ...inventory[idx],
            name,
            quantity: qty,
            group,
            details,
            updatedAt: now
          };
          setImagesForItem(adminEditId, formImages.map((img) => ({ ...img })));

          await saveInventory();
          await saveImages();
          await loadInventory();
          await loadImages();
          resetForm();
          setStatus("ITEM UPDATED");
        } catch (err) {
          console.error("SAVE FAILED:", err);
          setStatus("ERROR SAVING");
        }
        return;
      }

      const copyImages = formImages.map((img) => ({ ...img }));

      if (batchEditIndex === null) {
        batchItems.push({ ...baseItem, images: copyImages });
        setStatus("ITEM ADDED TO BATCH");
      } else {
        batchItems[batchEditIndex] = { ...baseItem, images: copyImages };
        setStatus("BATCH ITEM UPDATED");
      }

      renderBatch();
      resetForm();
    });

    cancelEditBtn.addEventListener("click", () => resetForm());

    appTitle.addEventListener("click", () => {
      if (currentRole === "admin") {
        currentRole = "staff";
        resetForm();
        updateRoleUI();
        return;
      }

      const pwd = prompt("ENTER ADMIN PASSWORD:");
      if (!pwd) return;
      if (pwd !== ADMIN_PASSWORD) {
        alert("WRONG PASSWORD.");
        return;
      }

      currentRole = "admin";
      updateRoleUI();
      Promise.all([loadInventory(), loadImages()]);
    });

    tabButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        setAdminMainTab(btn.dataset.tab);
      });
    });

    batchFilterButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        currentBatchFilter = btn.dataset.batchView || "pending";
        batchFilterButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        renderAdminViews();
      });
    });

    batchSearchBtn.addEventListener("click", () => {
      batchSearchName = (batchSearchNameInput.value || "").trim().toUpperCase();
      batchSearchDate = batchSearchDateInput.value || "";
      renderAdminViews();
    });

    batchClearSearchBtn.addEventListener("click", () => {
      batchSearchNameInput.value = "";
      batchSearchDateInput.value = "";
      batchSearchName = "";
      batchSearchDate = "";
      renderAdminViews();
    });

    itemSearchBtn.addEventListener("click", () => {
      itemSearchTerm = (itemSearchInput.value || "").trim().toUpperCase();
      reportDateFrom = reportDateFromInput.value || "";
      reportDateTo = reportDateToInput.value || "";
      reportGroupFilter = (reportGroupInput.value || "").trim().toUpperCase();
      reportStatusFilter = (reportStatusSelect.value || "ALL").toUpperCase();
      reportBatchNameFilter = (reportBatchInput.value || "").trim().toUpperCase();
      renderAdminViews();
    });

    itemClearSearchBtn.addEventListener("click", () => {
      itemSearchInput.value = "";
      reportDateFromInput.value = "";
      reportDateToInput.value = "";
      reportGroupInput.value = "";
      reportStatusSelect.value = "ALL";
      reportBatchInput.value = "";
      itemSearchTerm = "";
      reportDateFrom = "";
      reportDateTo = "";
      reportGroupFilter = "";
      reportStatusFilter = "ALL";
      reportBatchNameFilter = "";
      itemSearchResult.textContent = "";
      renderAdminViews();
    });

    pendingBadge.addEventListener("click", () => {
      if (currentRole !== "admin") return;
      setAdminMainTab("batches");
      currentBatchFilter = "pending";
      batchFilterButtons.forEach((b) => {
        b.classList.toggle("active", b.dataset.batchView === "pending");
      });
      renderAdminViews();
      adminCard.scrollIntoView({ behavior: "smooth" });
      playBellSound();
    });

    let viewerScale = 1;
    let viewerTranslateX = 0;
    let viewerTranslateY = 0;
    let viewerPointers = new Map();
    let viewerInitialDistance = 0;
    let viewerInitialScale = 1;
    let viewerLastX = 0;
    let viewerLastY = 0;

    function applyViewerTransform() {
      viewerImage.style.transform =
        `translate(${viewerTranslateX}px, ${viewerTranslateY}px) scale(${viewerScale})`;
    }

    function resetViewerTransform() {
      viewerScale = 1;
      viewerTranslateX = 0;
      viewerTranslateY = 0;
      applyViewerTransform();
    }

    function openImageViewer(imagesArray, startIndex, options) {
      if (!imagesArray || !imagesArray.length) return;
      viewerState.source = options.source || null;
      viewerState.images = imagesArray;
      viewerState.index = startIndex || 0;
      viewerState.deletable = !!options.deletable;
      viewerState.onChange = options.onChange || null;

      viewerDeleteBtn.style.display = viewerState.deletable ? "inline-flex" : "none";

      showViewerImage(viewerState.index);
      resetViewerTransform();
      imageViewer.style.display = "flex";
    }

    function closeImageViewer() {
      imageViewer.style.display = "none";
      viewerState.source = null;
      viewerState.images = [];
      viewerState.index = 0;
      viewerState.deletable = false;
      viewerState.onChange = null;
      resetViewerTransform();
    }

    function showViewerImage(i) {
      if (!viewerState.images.length) return;
      if (i < 0) i = 0;
      if (i >= viewerState.images.length) i = viewerState.images.length - 1;
      viewerState.index = i;
      const img = viewerState.images[i];
      viewerImage.style.display = "block";
      viewerImage.src = img.dataUrl;
      viewerCounter.textContent = `${i + 1} / ${viewerState.images.length}`;
      resetViewerTransform();
    }

    function nextViewerImage() {
      if (!viewerState.images.length) return;
      const i = (viewerState.index + 1) % viewerState.images.length;
      showViewerImage(i);
    }

    function prevViewerImage() {
      if (!viewerState.images.length) return;
      const i =
        (viewerState.index - 1 + viewerState.images.length) %
        viewerState.images.length;
      showViewerImage(i);
    }

    viewerCloseBtn.addEventListener("click", closeImageViewer);
    viewerPrevBtn.addEventListener("click", prevViewerImage);
    viewerNextBtn.addEventListener("click", nextViewerImage);

    viewerDeleteBtn.addEventListener("click", () => {
      if (!viewerState.deletable || !viewerState.images.length) return;
      const idx = viewerState.index;
      const newArr = viewerState.images.filter((_, i) => i !== idx);
      viewerState.images = newArr;
      if (viewerState.onChange) viewerState.onChange(newArr);
      if (!newArr.length) {
        closeImageViewer();
        return;
      }
      const newIndex = Math.min(idx, newArr.length - 1);
      showViewerImage(newIndex);
    });

    imageViewer.addEventListener("click", (e) => {
      if (e.target === imageViewer) {
        closeImageViewer();
      }
    });

    document.addEventListener("keydown", (e) => {
      if (imageViewer.style.display !== "flex") return;
      if (e.key === "Escape") {
        closeImageViewer();
      } else if ((e.key === "x" || e.key === "X") && viewerState.deletable) {
        viewerDeleteBtn.click();
      } else if (e.key === "ArrowRight") {
        nextViewerImage();
      } else if (e.key === "ArrowLeft") {
        prevViewerImage();
      }
    });

    viewerWrapper.addEventListener("pointerdown", (e) => {
      viewerWrapper.setPointerCapture(e.pointerId);
      viewerPointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (viewerPointers.size === 1) {
        viewerLastX = e.clientX;
        viewerLastY = e.clientY;
      } else if (viewerPointers.size === 2) {
        const arr = Array.from(viewerPointers.values());
        const dx = arr[1].x - arr[0].x;
        const dy = arr[1].y - arr[0].y;
        viewerInitialDistance = Math.hypot(dx, dy);
        viewerInitialScale = viewerScale;
      }
    });

    viewerWrapper.addEventListener("pointermove", (e) => {
      if (!viewerPointers.has(e.pointerId)) return;
      viewerPointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (viewerPointers.size === 1) {
        const dx = e.clientX - viewerLastX;
        const dy = e.clientY - viewerLastY;
        viewerLastX = e.clientX;
        viewerLastY = e.clientY;
        viewerTranslateX += dx;
        viewerTranslateY += dy;
        applyViewerTransform();
      } else if (viewerPointers.size === 2) {
        const arr = Array.from(viewerPointers.values());
        const dx = arr[1].x - arr[0].x;
        const dy = arr[1].y - arr[0].y;
        const dist = Math.hypot(dx, dy);
        if (viewerInitialDistance > 0) {
          let newScale = viewerInitialScale * (dist / viewerInitialDistance);
          newScale = Math.max(1, Math.min(4, newScale));
          viewerScale = newScale;
          applyViewerTransform();
        }
      }
    });

    viewerWrapper.addEventListener("pointerup", (e) => {
      viewerWrapper.releasePointerCapture(e.pointerId);
      viewerPointers.delete(e.pointerId);
      if (viewerPointers.size === 1) {
        const remaining = Array.from(viewerPointers.values())[0];
        viewerLastX = remaining.x;
        viewerLastY = remaining.y;
      }
    });

    viewerWrapper.addEventListener("pointercancel", (e) => {
      viewerWrapper.releasePointerCapture(e.pointerId);
      viewerPointers.delete(e.pointerId);
    });

    let touchStartX = 0;
    let touchStartY = 0;
    imageViewer.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }
    });

    imageViewer.addEventListener("touchend", (e) => {
      if (e.changedTouches.length === 0) return;
      const dx = e.changedTouches[0].clientX - touchStartX;
      const dy = e.changedTouches[0].clientY - touchStartY;
      if (Math.abs(dx) > 50 && Math.abs(dy) < 40 && viewerScale === 1) {
        if (dx < 0) nextViewerImage();
        else prevViewerImage();
      }
    });

    document.addEventListener("click", (e) => {
      const imgEl = e.target.closest("img[data-view-source]");
      if (!imgEl) return;

      const source = imgEl.dataset.viewSource;
      const index = Number(imgEl.dataset.viewIndex || 0);

      if (source === "form") {
        openImageViewer(formImages, index, {
          source: "form",
          deletable: true,
          onChange: (newArr) => {
            formImages = newArr;
            renderFormImages();
          }
        });
      } else if (source === "modal") {
        openImageViewer(modalImages, index, {
          source: "modal",
          deletable: true,
          onChange: (newArr) => {
            modalImages = newArr;
            renderModalImages();
          }
        });
      }
    });

    (async function init() {
      updateRoleUI();
      renderBatch();
      await loadInventory();
      await loadImages();
    })();
  </script>
</body>
</html>
