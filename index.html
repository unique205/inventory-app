<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>INVENTORY SYSTEM</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --card: #020617;
      --border: #1f2937;
      --accent: #4f46e5;
      --accent-soft: #6366f1;
      --danger: #b91c1c;
      --danger-soft: #dc2626;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text-main);
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.7rem 1rem;
      border-bottom: 1px solid var(--border);
      background: #020617;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    header h1 {
      margin: 0;
      font-size: 1.1rem;
      cursor: pointer;
      user-select: none;
    }

    .badge {
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid #4b5563;
      background: #111827;
    }

    .badge-staff {
      border-color: #3b82f6;
      color: #bfdbfe;
    }

    .badge-admin {
      border-color: #22c55e;
      color: #bbf7d0;
    }

    main {
      max-width: 1040px;
      margin: 1rem auto 2rem;
      padding: 0 0.75rem;
    }

    .card {
      background: var(--card);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.9rem 0.9rem 1.1rem;
      margin-bottom: 1rem;
    }

    .card h2 {
      margin: 0 0 0.6rem;
      font-size: 1rem;
    }

    label {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: block;
      margin-bottom: 0.15rem;
    }

    .field-row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0.6rem;
      margin-bottom: 0.6rem;
    }

    input,
    textarea,
    button,
    select {
      font: inherit;
      border-radius: 0.4rem;
      border: 1px solid #374151;
      background: #020617;
      color: var(--text-main);
      padding: 0.4rem 0.55rem;
    }

    input.upper,
    textarea.upper {
      text-transform: uppercase;
    }

    textarea {
      min-height: 50px;
      resize: vertical;
    }

    button {
      cursor: pointer;
      background: var(--accent);
      border-color: var(--accent);
      font-weight: 500;
      font-size: 0.85rem;
    }

    button:hover {
      background: var(--accent-soft);
    }

    button.secondary {
      background: #111827;
      border-color: #4b5563;
    }

    button.secondary:hover {
      background: #1f2937;
    }

    button.danger {
      background: var(--danger);
      border-color: var(--danger);
    }

    button.danger:hover {
      background: var(--danger-soft);
    }

    button.small {
      padding: 0.22rem 0.45rem;
      font-size: 0.7rem;
      margin-right: 0.25rem;
    }

    .actions-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.4rem;
    }

    .actions-row > button {
      flex: 0 0 auto;
    }

    .status {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .muted {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .table-wrapper {
      margin-top: 0.4rem;
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
      text-transform: uppercase;
    }

    th,
    td {
      padding: 0.35rem 0.35rem;
      border-bottom: 1px solid var(--border);
      text-align: left;
      white-space: nowrap;
    }

    th {
      background: #020617;
    }

    tr:hover td {
      background: #020617;
    }

    .batch-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.45rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border);
      margin-bottom: 0.4rem;
      font-size: 0.78rem;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .tab-row {
      display: flex;
      gap: 0.4rem;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
    }

    .tab-btn {
      background: #111827;
      border-color: #4b5563;
      font-size: 0.8rem;
      padding: 0.3rem 0.6rem;
    }

    .tab-btn.active {
      background: var(--accent);
      border-color: var(--accent);
    }

    /* Highlight for searched items */
    tr.highlight-row td {
      background: #111827;
      border-bottom-color: var(--accent-soft);
    }

    /* Item name suggestions */
    .name-input-wrapper {
      position: relative;
    }

    .suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #020617;
      border: 1px solid #374151;
      border-radius: 0.4rem;
      margin-top: 0.15rem;
      max-height: 160px;
      overflow-y: auto;
      font-size: 0.75rem;
      display: none;
      z-index: 20;
    }

    .suggestion-item {
      padding: 0.25rem 0.45rem;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .suggestion-item:hover {
      background: #111827;
    }

    /* Image thumbnails */
    .image-thumbs {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-top: 0.25rem;
    }

    .image-thumb {
      position: relative;
      width: 70px;
      height: 70px;
      border-radius: 0.4rem;
      overflow: hidden;
      border: 1px solid #374151;
      background: #020617;
    }

    .image-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .image-thumb button {
      position: absolute;
      top: 2px;
      right: 2px;
      padding: 0 4px;
      font-size: 0.6rem;
      border-radius: 999px;
    }

    /* Bell animation */
    #pending-badge.bell-alert {
      border-color: #f97316;
      color: #fecaca;
      box-shadow: 0 0 10px #f97316;
      animation: bellRing 0.9s infinite;
    }

    @keyframes bellRing {
      0% { transform: translateX(0) rotate(0); }
      20% { transform: translateX(-1px) rotate(-5deg); }
      40% { transform: translateX(1px) rotate(5deg); }
      60% { transform: translateX(-1px) rotate(-5deg); }
      80% { transform: translateX(1px) rotate(5deg); }
      100% { transform: translateX(0) rotate(0); }
    }

    /* ===== SMALL SCREENS ===== */
    @media (max-width: 640px) {
      header {
        gap: 0.5rem;
      }

      header h1 {
        font-size: 1rem;
      }

      .actions-row {
        flex-direction: column;
        align-items: stretch;
      }

      .actions-row > button {
        width: 100%;
      }

      button.small {
        width: 100%;
        margin-right: 0;
      }

      /* Hide ID column on narrow screens */
      th:nth-child(1),
      td:nth-child(1) {
        display: none;
      }

      td.actions-cell {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }
    }

    @media (min-width: 641px) {
      .field-row {
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }
    }
  </style>
</head>
<body>
  <header>
    <h1 id="app-title">INVENTORY SYSTEM</h1>
    <span id="role-badge" class="badge badge-staff">STAFF</span>
  </header>

  <main>
    <!-- STAFF ADD + BATCH (moves into admin panel when admin logs in) -->
    <div id="staff-batch-wrapper">
      <!-- ADD / EDIT FORM -->
      <section class="card">
        <h2 id="form-title">ADD ITEM</h2>
        <form id="item-form">
          <div class="field-row">
            <div>
              <label for="item-name">ITEM NAME *</label>
              <div class="name-input-wrapper">
                <input id="item-name" class="upper" autocomplete="off" required />
                <div id="item-suggestions" class="suggestions"></div>
              </div>
            </div>
            <div>
              <label for="item-qty">QUANTITY *</label>
              <input id="item-qty" type="number" min="0" step="1" required />
            </div>
            <div>
              <label for="item-group">GROUP</label>
              <input id="item-group" class="upper" placeholder="E.G. RAW MATERIAL" />
            </div>
          </div>

          <div>
            <label for="item-details">DETAILS</label>
            <textarea id="item-details" class="upper" placeholder="GRADE, BRAND, ETC."></textarea>
          </div>

          <!-- IMAGES -->
          <div style="margin-top:0.5rem;">
            <label>IMAGES (REQUIRED, MAX 10, â‰¤ 2MB EACH)</label>
            <div class="actions-row" style="margin-top:0.25rem;">
              <button type="button" id="add-image-btn" class="secondary small">
                UPLOAD / CAPTURE
              </button>
              <span class="muted" id="image-status-text"></span>
            </div>
            <input
              id="item-images-input"
              type="file"
              accept="image/*"
              multiple
              style="display:none;"
            />
            <div id="item-images-list">
              <p class="muted">NO IMAGES ADDED.</p>
            </div>
          </div>

          <div class="actions-row" style="margin-top:0.6rem;">
            <button type="submit" id="submit-btn">ADD TO BATCH</button>
            <button type="button" id="cancel-edit-btn" class="secondary" style="display:none;">CANCEL</button>
            <div class="status">STATUS: <span id="status-text">IDLE</span></div>
          </div>
        </form>
      </section>

      <!-- CURRENT BATCH -->
      <section class="card">
        <h2>CURRENT BATCH (NOT UPLOADED)</h2>
        <p class="muted" id="batch-info">
          ADD ITEMS ABOVE. THEY WILL APPEAR HERE UNTIL YOU UPLOAD THE BATCH.
        </p>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>ID</th>
                <th>NAME</th>
                <th>QTY</th>
                <th>GROUP</th>
                <th>DETAILS</th>
                <th>ACTIONS</th>
              </tr>
            </thead>
            <tbody id="batch-body"></tbody>
          </table>
        </div>
        <div class="actions-row" style="margin-top:0.6rem;">
          <button type="button" id="upload-batch-btn" class="secondary">UPLOAD BATCH</button>
          <span class="muted" id="batch-status"></span>
        </div>
      </section>
    </div>

    <!-- ADMIN PANEL -->
    <section class="card" id="admin-card" style="display:none;">
      <h2>
        ADMIN PANEL
        <span id="pending-badge" class="badge">ðŸ”” 0</span>
      </h2>

      <!-- MAIN ADMIN TABS -->
      <div class="tab-row">
        <button type="button" class="tab-btn admin-main-tab" data-tab="add">ADD ITEMS</button>
        <button type="button" class="tab-btn admin-main-tab active" data-tab="batches">BATCHES</button>
        <button type="button" class="tab-btn admin-main-tab" data-tab="items">ALL ITEMS</button>
      </div>

      <!-- ADMIN ADD ITEMS TAB (reuses staff add+batch UI) -->
      <div id="admin-add-tab" style="display:none;">
        <div id="admin-add-container"></div>
      </div>

      <!-- ADMIN BATCHES TAB -->
      <div id="admin-batches-tab">
        <!-- Pending / Approved mini-tabs -->
        <div class="tab-row" id="batch-status-tabs" style="margin-bottom:0.4rem;">
          <button type="button" class="tab-btn small batch-filter-tab active" data-batch-view="pending">PENDING</button>
          <button type="button" class="tab-btn small batch-filter-tab" data-batch-view="approved">APPROVED</button>
        </div>

        <!-- Selected batch details -->
        <div id="batch-items-wrapper" style="margin-top:0.3rem; display:none;">
          <div class="actions-row" style="margin-bottom:0.3rem;">
            <span class="muted" id="selected-batch-label">NO BATCH SELECTED.</span>
            <button type="button" id="approve-batch-btn" class="secondary">
              APPROVE
            </button>
            <button type="button" id="send-whatsapp-btn" class="secondary">
              SEND WHATSAPP
            </button>
          </div>
          <div class="table-wrapper">
            <table>
              <thead>
                <tr>
                  <th>ID</th>
                  <th>NAME</th>
                  <th>QTY</th>
                  <th>GROUP</th>
                  <th>DETAILS</th>
                  <th>UPDATED AT</th>
                  <th>ACTIONS</th>
                </tr>
              </thead>
              <tbody id="admin-batch-body"></tbody>
            </table>
          </div>
        </div>

        <!-- Batch list -->
        <div class="muted" id="batch-list-info" style="margin-top:0.6rem;">LOADINGâ€¦</div>

        <!-- Batch search controls -->
        <div class="field-row" style="margin:0.4rem 0;">
          <div>
            <label for="batch-search-name">SEARCH BATCH BY NAME</label>
            <input id="batch-search-name" placeholder="TYPE BATCH NAMEâ€¦" />
          </div>
          <div>
            <label for="batch-search-date">SEARCH BATCH BY DATE</label>
            <input id="batch-search-date" type="date" />
          </div>
        </div>
        <div class="actions-row" style="margin-top:0.2rem;">
          <button type="button" id="batch-search-btn" class="secondary small">SEARCH</button>
          <button type="button" id="batch-clear-search-btn" class="secondary small">CLEAR</button>
        </div>

        <div id="batch-list" style="margin-top:0.4rem;"></div>
      </div>

      <!-- ADMIN ALL ITEMS TAB (reports) -->
      <div id="admin-items-tab" style="display:none;">
        <div class="muted" id="count-info">LOADINGâ€¦</div>

        <div class="field-row" style="margin-top:0.4rem;">
          <div>
            <label for="item-search-input">ITEM NAME</label>
            <input id="item-search-input" placeholder="TYPE ITEM NAMEâ€¦" class="upper" />
          </div>
          <div>
            <label for="report-date-from">DATE FROM (BATCH)</label>
            <input id="report-date-from" type="date" />
          </div>
          <div>
            <label for="report-date-to">DATE TO (BATCH)</label>
            <input id="report-date-to" type="date" />
          </div>
        </div>

        <div class="field-row" style="margin-top:0.4rem;">
          <div>
            <label for="report-group">GROUP</label>
            <input id="report-group" class="upper" placeholder="E.G. RAW MATERIAL" />
          </div>
          <div>
            <label for="report-status">STATUS</label>
            <select id="report-status">
              <option value="ALL">ALL</option>
              <option value="PENDING">PENDING</option>
              <option value="APPROVED">APPROVED</option>
            </select>
          </div>
          <div>
            <label for="report-batch">BATCH NAME</label>
            <input id="report-batch" class="upper" placeholder="TYPE BATCH NAMEâ€¦" />
          </div>
        </div>

        <div class="actions-row" style="margin-top:0.2rem;">
          <button type="button" id="item-search-btn" class="secondary small">APPLY FILTERS</button>
          <button type="button" id="item-clear-search-btn" class="secondary small">CLEAR FILTERS</button>
          <span class="muted" id="item-search-result"></span>
        </div>

        <div class="table-wrapper" style="margin-top:0.4rem;">
          <table>
            <thead>
              <tr>
                <th>ID</th>
                <th>NAME</th>
                <th>QTY</th>
                <th>GROUP</th>
                <th>DETAILS</th>
                <th>BATCH TIME</th>
                <th>UPDATED AT</th>
                <th>ACTIONS</th>
              </tr>
            </thead>
            <tbody id="inventory-body"></tbody>
          </table>
        </div>
      </div>
    </section>
  </main>

  <script>
    // ===== CONFIG =====
    const BACKEND_URL = "https://inventory-backend-s4sv.onrender.com/get-token";
    const NOTIFY_URL = "https://inventory-backend-s4sv.onrender.com/notify-batch";
    const REPO_OWNER = "unique205";
    const REPO_NAME = "inventory-data";
    const FILE_PATH = "data/inventory.json";
    const IMAGES_FILE_PATH = "images.json"; // <-- images.json at repo root
    const BRANCH = "main";
    const ADMIN_PASSWORD = "admin123";
    const ADMIN_PHONE = "917588756668";
    const WHATSAPP_PHONE = ADMIN_PHONE;

    // ===== STATE =====
    let currentRole = "staff";
    let inventory = [];
    let currentSha = null;
    let batchItems = [];
    let batchEditIndex = null;
    let adminEditId = null;
    let selectedBatchKey = null;

    // images
    let imagesStore = []; // [{itemId, images:[{id,name,size,dataUrl}]}]
    let imagesSha = null;
    let formImages = []; // current item images (for add/edit)

    // Search/filter
    let batchSearchName = "";
    let batchSearchDate = "";
    let itemSearchTerm = "";
    let currentBatchFilter = "pending";
    let reportDateFrom = "";
    let reportDateTo = "";
    let reportGroupFilter = "";
    let reportStatusFilter = "ALL";
    let reportBatchNameFilter = "";

    // ===== DOM =====
    const appTitle = document.getElementById("app-title");
    const roleBadge = document.getElementById("role-badge");

    const mainEl = document.querySelector("main");
    const staffBatchWrapper = document.getElementById("staff-batch-wrapper");

    // form
    const itemForm = document.getElementById("item-form");
    const itemNameInput = document.getElementById("item-name");
    const itemQtyInput = document.getElementById("item-qty");
    const itemGroupInput = document.getElementById("item-group");
    const itemDetailsInput = document.getElementById("item-details");
    const submitBtn = document.getElementById("submit-btn");
    const cancelEditBtn = document.getElementById("cancel-edit-btn");
    const formTitle = document.getElementById("form-title");
    const statusText = document.getElementById("status-text");

    const nameInputWrapper = document.querySelector(".name-input-wrapper");
    const itemSuggestions = document.getElementById("item-suggestions");

    const addImageBtn = document.getElementById("add-image-btn");
    const imageInput = document.getElementById("item-images-input");
    const imageList = document.getElementById("item-images-list");
    const imageStatusText = document.getElementById("image-status-text");

    // batch
    const batchBody = document.getElementById("batch-body");
    const uploadBatchBtn = document.getElementById("upload-batch-btn");
    const batchStatus = document.getElementById("batch-status");

    // admin
    const adminCard = document.getElementById("admin-card");
    const pendingBadge = document.getElementById("pending-badge");
    const adminAddTab = document.getElementById("admin-add-tab");
    const adminAddContainer = document.getElementById("admin-add-container");
    const adminBatchesTab = document.getElementById("admin-batches-tab");
    const adminItemsTab = document.getElementById("admin-items-tab");
    const tabButtons = document.querySelectorAll(".admin-main-tab");

    const batchListInfo = document.getElementById("batch-list-info");
    const batchList = document.getElementById("batch-list");
    const batchItemsWrapper = document.getElementById("batch-items-wrapper");
    const selectedBatchLabel = document.getElementById("selected-batch-label");
    const approveBatchBtn = document.getElementById("approve-batch-btn");
    const sendWhatsAppBtn = document.getElementById("send-whatsapp-btn");
    const adminBatchBody = document.getElementById("admin-batch-body");
    const batchSearchNameInput = document.getElementById("batch-search-name");
    const batchSearchDateInput = document.getElementById("batch-search-date");
    const batchSearchBtn = document.getElementById("batch-search-btn");
    const batchClearSearchBtn = document.getElementById("batch-clear-search-btn");
    const batchFilterButtons = document.querySelectorAll(".batch-filter-tab");

    const countInfo = document.getElementById("count-info");
    const inventoryBody = document.getElementById("inventory-body");
    const itemSearchInput = document.getElementById("item-search-input");
    const itemSearchBtn = document.getElementById("item-search-btn");
    const itemClearSearchBtn = document.getElementById("item-clear-search-btn");
    const itemSearchResult = document.getElementById("item-search-result");
    const reportDateFromInput = document.getElementById("report-date-from");
    const reportDateToInput = document.getElementById("report-date-to");
    const reportGroupInput = document.getElementById("report-group");
    const reportStatusSelect = document.getElementById("report-status");
    const reportBatchInput = document.getElementById("report-batch");

    // ===== UTILS =====
    function setStatus(msg) {
      statusText.textContent = msg.toUpperCase();
    }

    function generateId() {
      const ts = Date.now();
      const rand = Math.random().toString(36).substring(2, 8);
      return `ITEM_${ts}_${rand.toUpperCase()}`;
    }

    function generateBatchId() {
      const ts = Date.now();
      const rand = Math.random().toString(36).substring(2, 8).toUpperCase();
      return `BATCH_${ts}_${rand}`;
    }

    function generateImageId() {
      const ts = Date.now();
      const rand = Math.random().toString(36).substring(2, 6).toUpperCase();
      return `IMG_${ts}_${rand}`;
    }

    function formatDate(iso) {
      if (!iso) return "-";
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return String(iso).toUpperCase();
      return d.toLocaleString().toUpperCase();
    }

    function getBatchKeyForItem(item) {
      return item.batchId || item.batchTime || item.timestamp || "UNKNOWN";
    }

    function getBatchTimeForItem(item) {
      return item.batchTime || item.timestamp || null;
    }

    function getStatusDisplay(statusRaw) {
      const s = (statusRaw || "PENDING").toUpperCase();
      if (s === "APPROVED") return "âœ… APPROVED";
      return "ðŸŸ¡ PENDING";
    }

    async function getBackendToken() {
      try {
        const res = await fetch(BACKEND_URL, { method: "POST" });
        if (!res.ok) return null;
        const data = await res.json().catch(() => ({}));
        return data.token || null;
      } catch {
        return null;
      }
    }

    async function githubRequest(path, options = {}) {
      const token = await getBackendToken();
      if (!token) throw new Error("BACKEND TOKEN REQUEST FAILED");

      const res = await fetch(`https://api.github.com${path}`, {
        ...options,
        headers: {
          "Authorization": `Bearer ${token}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json",
          ...(options.headers || {})
        }
      });

      if (!res.ok) {
        const text = await res.text();
        throw new Error(`GITHUB ERROR ${res.status}: ${text}`);
      }
      return res.json();
    }

    function resetForm() {
      itemNameInput.value = "";
      itemQtyInput.value = "";
      itemGroupInput.value = "";
      itemDetailsInput.value = "";
      batchEditIndex = null;
      adminEditId = null;
      formImages = [];
      renderFormImages();

      submitBtn.textContent = "ADD TO BATCH";
      formTitle.textContent = currentRole === "admin" ? "ADD ITEM (ADMIN)" : "ADD ITEM";
      cancelEditBtn.style.display = "none";
    }

    function moveStaffUIForRole() {
      if (!staffBatchWrapper || !adminCard || !mainEl || !adminAddContainer) return;
      if (currentRole === "admin") {
        if (staffBatchWrapper.parentNode !== adminAddContainer) {
          adminAddContainer.appendChild(staffBatchWrapper);
        }
      } else {
        if (staffBatchWrapper.parentNode !== mainEl) {
          mainEl.insertBefore(staffBatchWrapper, adminCard);
        }
      }
    }

    function setAdminMainTab(tab) {
      tabButtons.forEach((b) => {
        b.classList.toggle("active", b.dataset.tab === tab);
      });
      adminAddTab.style.display = tab === "add" ? "block" : "none";
      adminBatchesTab.style.display = tab === "batches" ? "block" : "none";
      adminItemsTab.style.display = tab === "items" ? "block" : "none";
    }

    function updateRoleUI() {
      moveStaffUIForRole();

      if (currentRole === "admin") {
        roleBadge.textContent = "ADMIN";
        roleBadge.className = "badge badge-admin";
        adminCard.style.display = "block";
        setAdminMainTab("batches");
      } else {
        roleBadge.textContent = "STAFF";
        roleBadge.className = "badge badge-staff";
        adminCard.style.display = "none";
      }
      renderBatch();
      renderAdminViews();
    }

    function playBellSound() {
      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const ctx = new AudioContext();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = "sine";
        osc.frequency.value = 880;
        osc.connect(gain);
        gain.connect(ctx.destination);
        gain.gain.value = 0.1;
        const now = ctx.currentTime;
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
        osc.start(now);
        osc.stop(now + 0.6);
      } catch {}
    }

    // ===== PWA REGISTER =====
    function registerPWA() {
      if (!("serviceWorker" in navigator)) return;

      try {
        const manifest = {
          name: "Inventory System",
          short_name: "Inventory",
          start_url: ".",
          display: "standalone",
          background_color: "#020617",
          theme_color: "#020617",
          icons: []
        };
        const blob = new Blob([JSON.stringify(manifest)], { type: "application/json" });
        const manifestURL = URL.createObjectURL(blob);
        const link = document.createElement("link");
        link.rel = "manifest";
        link.href = manifestURL;
        document.head.appendChild(link);
      } catch {}

      const swCode = `
        const CACHE_NAME = 'inventory-app-v1';
        const OFFLINE_URLS = ['.', self.location.href];
        self.addEventListener('install', (event) => {
          event.waitUntil(
            caches.open(CACHE_NAME)
              .then((cache) => cache.addAll(OFFLINE_URLS))
              .then(() => self.skipWaiting())
          );
        });
        self.addEventListener('activate', (event) => {
          event.waitUntil(
            caches.keys().then((keys) =>
              Promise.all(keys.map((key) => (key === CACHE_NAME ? null : caches.delete(key))))
            ).then(() => self.clients.claim())
          );
        });
        self.addEventListener('fetch', (event) => {
          const req = event.request;
          if (req.method !== 'GET') return;
          event.respondWith(
            caches.match(req).then((cached) => {
              if (cached) return cached;
              return fetch(req).then((res) => {
                const resClone = res.clone();
                caches.open(CACHE_NAME).then((cache) => cache.put(req, resClone));
                return res;
              }).catch(() => caches.match('.'));
            })
          );
        });
      `;
      try {
        const blob = new Blob([swCode], { type: "text/javascript" });
        const swUrl = URL.createObjectURL(blob);
        navigator.serviceWorker.register(swUrl).catch(() => {});
      } catch {}
    }

    // ===== INVENTORY LOAD/SAVE + BACKUP =====
    async function loadInventory() {
      try {
        setStatus("LOADING FROM GITHUBâ€¦");
        const data = await githubRequest(
          `/repos/${REPO_OWNER}/${REPO_NAME}/contents/${encodeURIComponent(FILE_PATH)}?ref=${BRANCH}`
        );

        currentSha = data.sha;
        const decoded = atob(data.content.replace(/\n/g, ""));
        inventory = decoded.trim() ? JSON.parse(decoded) : [];

        try {
          localStorage.setItem("inventory_cache", JSON.stringify(inventory));
          localStorage.removeItem("inventory_pending_save");
        } catch {}

        renderAdminViews();
        setStatus("LOADED");
      } catch (err) {
        console.error("ERROR LOADING INVENTORY:", err);
        currentSha = null;
        try {
          const cached = localStorage.getItem("inventory_cache");
          if (cached) {
            inventory = JSON.parse(cached);
            renderAdminViews();
            setStatus("OFFLINE â€“ USING CACHED INVENTORY");
            return;
          }
        } catch {}
        inventory = [];
        renderAdminViews();
        setStatus("WORKING OFFLINE (NO CACHE)");
      }
    }

    async function createBackup(snapshot) {
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
      const backupPath = `backups/inventory-${timestamp}.json`;
      const content = btoa(snapshot);
      const body = {
        message: `BACKUP INVENTORY ${timestamp}`,
        content,
        branch: BRANCH
      };
      await githubRequest(
        `/repos/${REPO_OWNER}/${REPO_NAME}/contents/${encodeURIComponent(backupPath)}`,
        { method: "PUT", body: JSON.stringify(body) }
      );
    }

    async function saveInventory() {
      const snapshot = JSON.stringify(inventory, null, 2);
      const content = btoa(snapshot);
      const body = {
        message: "UPDATE INVENTORY.JSON FROM INVENTORY-APP",
        content,
        branch: BRANCH
      };
      if (currentSha) body.sha = currentSha;

      try {
        const data = await githubRequest(
          `/repos/${REPO_OWNER}/${REPO_NAME}/contents/${encodeURIComponent(FILE_PATH)}`,
          { method: "PUT", body: JSON.stringify(body) }
        );
        currentSha = data.content.sha;

        try {
          localStorage.setItem("inventory_cache", snapshot);
          localStorage.removeItem("inventory_pending_save");
        } catch {}

        try {
          await createBackup(snapshot);
        } catch (e) {
          console.warn("BACKUP FAILED:", e);
        }
      } catch (err) {
        console.error("SAVE INVENTORY FAILED:", err);
        try {
          localStorage.setItem("inventory_cache", snapshot);
          localStorage.setItem("inventory_pending_save", JSON.stringify({ snapshot, ts: Date.now() }));
        } catch {}
        throw err;
      }
    }

    window.addEventListener("online", () => {
      try {
        const pendingStr = localStorage.getItem("inventory_pending_save");
        if (!pendingStr) return;
        const data = JSON.parse(pendingStr);
        if (!data || !data.snapshot) return;
        inventory = JSON.parse(data.snapshot);
        saveInventory()
          .then(() => {
            localStorage.removeItem("inventory_pending_save");
            loadInventory();
          })
          .catch((err) => console.error("RESYNC FAILED:", err));
      } catch (e) {
        console.error("RESYNC ERROR:", e);
      }
    });

    // ===== IMAGES LOAD/SAVE (SEPARATE FILE) =====
    async function loadImages() {
      try {
        const data = await githubRequest(
          `/repos/${REPO_OWNER}/${REPO_NAME}/contents/${encodeURIComponent(IMAGES_FILE_PATH)}?ref=${BRANCH}`
        );
        imagesSha = data.sha;
        const decoded = atob(data.content.replace(/\n/g, ""));
        imagesStore = decoded.trim() ? JSON.parse(decoded) : [];
        try {
          localStorage.setItem("images_cache", JSON.stringify(imagesStore));
        } catch {}
      } catch (err) {
        console.warn("LOAD IMAGES FAILED:", err);
        imagesSha = null;
        try {
          const cached = localStorage.getItem("images_cache");
          if (cached) {
            imagesStore = JSON.parse(cached);
            return;
          }
        } catch {}
        imagesStore = [];
      }
    }

    async function saveImages() {
      const snapshot = JSON.stringify(imagesStore, null, 2);
      const content = btoa(snapshot);
      const body = {
        message: "UPDATE IMAGES.JSON FROM INVENTORY-APP",
        content,
        branch: BRANCH
      };
      if (imagesSha) body.sha = imagesSha;

      const data = await githubRequest(
        `/repos/${REPO_OWNER}/${REPO_NAME}/contents/${encodeURIComponent(IMAGES_FILE_PATH)}`,
        { method: "PUT", body: JSON.stringify(body) }
      );
      imagesSha = data.content.sha;
      try {
        localStorage.setItem("images_cache", snapshot);
      } catch {}
    }

    function getImagesForItem(itemId) {
      const entry = imagesStore.find((e) => e.itemId === itemId);
      return entry ? entry.images || [] : [];
    }

    function setImagesForItem(itemId, images) {
      const idx = imagesStore.findIndex((e) => e.itemId === itemId);
      const payload = { itemId, images };
      if (idx === -1) imagesStore.push(payload);
      else imagesStore[idx] = payload;
    }

    // ===== BATCH UI =====
    function renderBatch() {
      batchBody.innerHTML = "";

      if (!batchItems.length) {
        batchBody.innerHTML =
          '<tr><td colspan="6" class="muted">NO ITEMS IN BATCH.</td></tr>';
      } else {
        batchItems.forEach((item, index) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${item.id}</td>
            <td>${item.name}</td>
            <td>${item.quantity}</td>
            <td>${item.group || ""}</td>
            <td>${item.details || ""}</td>
            <td class="actions-cell">
              <button class="small secondary" data-action="edit-batch" data-index="${index}">EDIT</button>
              <button class="small danger" data-action="remove-batch" data-index="${index}">REMOVE</button>
            </td>`;
          batchBody.appendChild(tr);
        });
      }
    }

    batchBody.addEventListener("click", (e) => {
      const btn = e.target;
      if (!btn.dataset.action) return;
      const idx = Number(btn.dataset.index);

      if (btn.dataset.action === "edit-batch") {
        const item = batchItems[idx];
        batchEditIndex = idx;
        itemNameInput.value = item.name;
        itemQtyInput.value = item.quantity;
        itemGroupInput.value = item.group || "";
        itemDetailsInput.value = item.details || "";
        formImages = (item.images || []).map((img) => ({ ...img }));
        renderFormImages();

        submitBtn.textContent = "UPDATE BATCH ITEM";
        cancelEditBtn.style.display = "inline-block";
        formTitle.textContent = currentRole === "admin" ? "EDIT ITEM (ADMIN)" : "EDIT BATCH ITEM";
        window.scrollTo({ top: 0, behavior: "smooth" });
      } else if (btn.dataset.action === "remove-batch") {
        batchItems.splice(idx, 1);
        renderBatch();
      }
    });

    uploadBatchBtn.addEventListener("click", async () => {
      if (!batchItems.length) {
        batchStatus.textContent = "NO ITEMS IN BATCH.";
        return;
      }

      try {
        setStatus("UPLOADING BATCHâ€¦");
        batchStatus.textContent = "UPLOADINGâ€¦";

        const batchTime = new Date().toISOString();
        const batchId = generateBatchId();

        await loadInventory();
        await loadImages();

        const enriched = batchItems.map((item) => ({
          ...item,
          batchId,
          batchTime,
          batchStatus: "PENDING",
          batchName: item.batchName || ""
        }));

        inventory = inventory.concat(enriched);

        enriched.forEach((item) => {
          const imgs = item.images || [];
          setImagesForItem(item.id, imgs);
        });

        await saveInventory();
        await saveImages();
        await loadInventory();
        await loadImages();

        batchItems = [];
        renderBatch();
        batchStatus.textContent =
          "BATCH UPLOADED AT " + formatDate(batchTime);
        setStatus("BATCH UPLOADED");
      } catch (err) {
        console.error("BATCH UPLOAD FAILED:", err);
        batchStatus.textContent = "ERROR UPLOADING BATCH.";
        setStatus("ERROR UPLOADING");
      }
    });

    // ===== IMAGE UI (FORM) =====
    function renderFormImages() {
      if (!imageList) return;
      if (!formImages.length) {
        imageList.innerHTML = '<p class="muted">NO IMAGES ADDED.</p>';
        imageStatusText.textContent = "";
        return;
      }

      const wrap = document.createElement("div");
      wrap.className = "image-thumbs";
      formImages.forEach((img) => {
        const div = document.createElement("div");
        div.className = "image-thumb";
        div.innerHTML = `
          <img src="${img.dataUrl}" alt="">
          <button type="button" class="danger small" data-img-id="${img.id}">X</button>
        `;
        wrap.appendChild(div);
      });
      imageList.innerHTML = "";
      imageList.appendChild(wrap);
      imageStatusText.textContent = `${formImages.length} IMAGE(S)`;
    }

    addImageBtn.addEventListener("click", () => {
      if (!imageInput) return;
      imageInput.click();
    });

    // Compress image to <= maxSizeBytes using canvas (JPEG)
    async function compressImageFile(file, maxSizeBytes) {
      const dataUrl = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            const maxDim = 1280;
            let width = img.width;
            let height = img.height;

            if (width > height && width > maxDim) {
              height = Math.round((height * maxDim) / width);
              width = maxDim;
            } else if (height >= width && height > maxDim) {
              width = Math.round((width * maxDim) / height);
              height = maxDim;
            }

            canvas.width = width;
            canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);

            let quality = 0.9;
            let out = canvas.toDataURL("image/jpeg", quality);

            const calcSize = (d) => Math.round((d.length * 3) / 4);

            while (calcSize(out) > maxSizeBytes && quality > 0.3) {
              quality -= 0.1;
              out = canvas.toDataURL("image/jpeg", quality);
            }

            if (calcSize(out) > maxSizeBytes) {
              resolve(null);
            } else {
              resolve(out);
            }
          };
          img.onerror = reject;
          img.src = e.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      }).catch(() => null);

      if (!dataUrl) return null;

      return {
        id: generateImageId(),
        name: file.name,
        size: Math.round((dataUrl.length * 3) / 4),
        dataUrl
      };
    }

    imageInput.addEventListener("change", (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;

      const maxImages = 10;
      const maxSize = 2 * 1024 * 1024; // 2MB
      let rejectedTooMany = false;
      let rejectedSize = false;

      (async () => {
        for (const file of files) {
          if (formImages.length >= maxImages) {
            rejectedTooMany = true;
            break;
          }

          const compressed = await compressImageFile(file, maxSize);
          if (!compressed) {
            rejectedSize = true;
            continue;
          }

          formImages.push(compressed);
        }

        renderFormImages();

        if (rejectedTooMany) {
          imageStatusText.textContent = "MAX 10 IMAGES REACHED.";
        } else if (rejectedSize) {
          imageStatusText.textContent = "SOME IMAGES COULD NOT BE COMPRESSED <= 2MB.";
        } else {
          imageStatusText.textContent = `${formImages.length} IMAGE(S)`;
        }

        imageInput.value = "";
      })();
    });

    imageList.addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-img-id]");
      if (!btn) return;
      const id = btn.dataset.imgId;
      formImages = formImages.filter((img) => img.id !== id);
      renderFormImages();
    });

    // ===== NAME SUGGESTIONS =====
    function clearSuggestions() {
      if (!itemSuggestions) return;
      itemSuggestions.innerHTML = "";
      itemSuggestions.style.display = "none";
    }

    function showItemSuggestions(term) {
      if (!itemSuggestions) return;
      const query = term.trim().toUpperCase();
      if (!query) {
        clearSuggestions();
        return;
      }

      const byName = new Map();
      inventory.forEach((it) => {
        const n = (it.name || "").toString().toUpperCase();
        if (!n) return;
        if (!byName.has(n)) byName.set(n, it);
      });

      const matches = [];
      byName.forEach((it, n) => {
        if (n.includes(query)) matches.push(it);
      });

      matches.sort((a, b) => {
        const na = (a.name || "").toString();
        const nb = (b.name || "").toString();
        return na.localeCompare(nb);
      });

      if (!matches.length) {
        clearSuggestions();
        return;
      }

      const limited = matches.slice(0, 8);
      itemSuggestions.innerHTML = "";
      limited.forEach((it) => {
        const div = document.createElement("div");
        div.className = "suggestion-item";
        div.dataset.name = (it.name || "").toString().toUpperCase();
        div.textContent = it.name || "";
        itemSuggestions.appendChild(div);
      });
      itemSuggestions.style.display = "block";
    }

    itemNameInput.addEventListener("input", () => {
      showItemSuggestions(itemNameInput.value);
    });

    itemSuggestions.addEventListener("click", (e) => {
      const target = e.target.closest(".suggestion-item");
      if (!target) return;
      const nameUpper = target.dataset.name || "";
      const match = inventory.find(
        (it) => (it.name || "").toString().toUpperCase() === nameUpper
      );
      if (!match) return;

      itemNameInput.value = (match.name || "").toString().toUpperCase();
      if (match.quantity != null) itemQtyInput.value = match.quantity;
      itemGroupInput.value = (match.group || "").toString().toUpperCase();
      itemDetailsInput.value = (match.details || "").toString().toUpperCase();
      formImages = getImagesForItem(match.id).map((img) => ({ ...img }));
      renderFormImages();
      clearSuggestions();
    });

    document.addEventListener("click", (e) => {
      if (nameInputWrapper && !nameInputWrapper.contains(e.target)) {
        clearSuggestions();
      }
    });

    // ===== GROUPING =====
    function groupByBatch() {
      const groups = {};
      inventory.forEach((item) => {
        const key = getBatchKeyForItem(item);
        if (!groups[key]) groups[key] = [];
        groups[key].push(item);
      });
      return groups;
    }

    // ===== ADMIN RENDER =====
    function renderAdminViews() {
      if (currentRole !== "admin") return;

      const groups = groupByBatch();
      const keys = Object.keys(groups).sort((a, b) => {
        const ia = groups[a][0];
        const ib = groups[b][0];
        const ta = getBatchTimeForItem(ia) || "";
        const tb = getBatchTimeForItem(ib) || "";
        const da = new Date(ta);
        const db = new Date(tb);
        if (isNaN(da) || isNaN(db)) return 0;
        return db - da;
      });

      // counts
      let pendingCount = 0;
      let approvedCount = 0;
      keys.forEach((k) => {
        const first = groups[k][0];
        const statusRaw = (first.batchStatus || "PENDING").toUpperCase();
        if (statusRaw === "APPROVED") approvedCount++;
        else pendingCount++;
      });

      if (pendingBadge) {
        pendingBadge.textContent = `ðŸ”” ${pendingCount}`;
        if (pendingCount > 0) pendingBadge.classList.add("bell-alert");
        else pendingBadge.classList.remove("bell-alert");
      }

      // BATCH LIST
      batchList.innerHTML = "";
      let shownCount = 0;

      keys.forEach((k) => {
        const items = groups[k];
        const first = items[0];
        const batchTime = getBatchTimeForItem(first) || k;
        const batchName = (first.batchName || "").trim();
        const displayName = batchName || formatDate(batchTime);
        const statusRaw = (first.batchStatus || "PENDING").toUpperCase();
        const statusDisplay = getStatusDisplay(statusRaw);

        if (currentBatchFilter === "pending" && statusRaw === "APPROVED") return;
        if (currentBatchFilter === "approved" && statusRaw !== "APPROVED") return;

        const nameFilter = batchSearchName;
        const dateFilter = batchSearchDate;
        const dateStr = (() => {
          const d = new Date(batchTime);
          if (isNaN(d)) return "";
          return d.toISOString().slice(0, 10);
        })();

        if (nameFilter && !displayName.toUpperCase().includes(nameFilter)) return;
        if (dateFilter && dateStr !== dateFilter) return;

        const div = document.createElement("div");
        div.className = "batch-header";
        div.innerHTML = `
          <span>BATCH: ${displayName}</span>
          <span>DATE: ${formatDate(batchTime)}</span>
          <span>ITEMS: ${items.length}</span>
          <span>STATUS: ${statusDisplay}</span>
          <span>
            <button class="small secondary" data-action="view-batch" data-key="${k}">VIEW</button>
            <button class="small secondary" data-action="rename-batch" data-key="${k}">RENAME</button>
          </span>`;
        batchList.appendChild(div);
        shownCount++;
      });

      if (!keys.length) {
        batchListInfo.textContent = "NO BATCHES FOUND.";
      } else {
        batchListInfo.textContent = `${pendingCount} PENDING â€¢ ${approvedCount} APPROVED (VIEW: ${currentBatchFilter.toUpperCase()}, SHOWING ${shownCount})`;
      }

      // ALL ITEMS (REPORTS)
      inventoryBody.innerHTML = "";
      if (!inventory.length) {
        countInfo.textContent = "NO ITEMS IN INVENTORY.";
        inventoryBody.innerHTML =
          '<tr><td colspan="8" class="muted">NO ITEMS.</td></tr>';
        itemSearchResult.textContent = "";
      } else {
        let filteredCount = 0;
        let matchCount = 0;
        let firstMatchInfo = null;

        inventory.forEach((item) => {
          const nameUpper = (item.name || "").toString().toUpperCase();
          const groupUpper = (item.group || "").toString().toUpperCase();
          const statusRaw = (item.batchStatus || "PENDING").toUpperCase();
          const batchNameUpper = (item.batchName || "").toString().toUpperCase();
          const batchKey = getBatchKeyForItem(item);
          const batchTime = getBatchTimeForItem(item) || batchKey;
          const batchDateStr = (() => {
            const d = new Date(batchTime);
            if (isNaN(d)) return "";
            return d.toISOString().slice(0, 10);
          })();

          if (itemSearchTerm && !nameUpper.includes(itemSearchTerm)) return;
          if (reportGroupFilter && !groupUpper.includes(reportGroupFilter)) return;
          if (reportStatusFilter !== "ALL" && statusRaw !== reportStatusFilter) return;
          if (reportBatchNameFilter && !batchNameUpper.includes(reportBatchNameFilter)) return;
          if (reportDateFrom && batchDateStr && batchDateStr < reportDateFrom) return;
          if (reportDateTo && batchDateStr && batchDateStr > reportDateTo) return;

          filteredCount++;

          const matchesName = itemSearchTerm && nameUpper.includes(itemSearchTerm);
          if (matchesName) {
            matchCount++;
            if (!firstMatchInfo) {
              const batchLabel = batchNameUpper
                ? item.batchName
                : formatDate(batchTime);
              const statusDisplay = getStatusDisplay(statusRaw);
              firstMatchInfo = {
                name: item.name,
                batchLabel,
                statusDisplay
              };
            }
          }

          const tr = document.createElement("tr");
          if (matchesName) tr.classList.add("highlight-row");
          tr.innerHTML = `
            <td>${item.id || "-"}</td>
            <td>${item.name || ""}</td>
            <td>${item.quantity ?? ""}</td>
            <td>${item.group || ""}</td>
            <td>${item.details || ""}</td>
            <td>${formatDate(item.batchTime || item.timestamp)}</td>
            <td>${formatDate(item.updatedAt || item.timestamp)}</td>
            <td class="actions-cell">
              <button class="small secondary" data-action="edit-item" data-id="${item.id}">EDIT</button>
              <button class="small danger" data-action="delete-item" data-id="${item.id}">DELETE</button>
            </td>`;
          inventoryBody.appendChild(tr);
        });

        if (!filteredCount) {
          inventoryBody.innerHTML =
            '<tr><td colspan="8" class="muted">NO ITEMS MATCH FILTERS.</td></tr>';
        }

        countInfo.textContent = `${filteredCount} ITEMS (FILTERED FROM ${inventory.length})`;

        if (itemSearchTerm && matchCount > 0 && firstMatchInfo) {
          itemSearchResult.textContent =
            `'${firstMatchInfo.name}' FOUND IN BATCH: ${firstMatchInfo.batchLabel} â€¢ STATUS: ${firstMatchInfo.statusDisplay}`;
        } else if (itemSearchTerm && filteredCount === 0) {
          itemSearchResult.textContent = "NO ITEMS FOUND FOR SEARCH.";
        } else {
          itemSearchResult.textContent = "";
        }
      }

      if (selectedBatchKey && groups[selectedBatchKey]) {
        renderSelectedBatchItems(selectedBatchKey, groups[selectedBatchKey]);
      } else {
        batchItemsWrapper.style.display = "none";
        selectedBatchLabel.textContent = "NO BATCH SELECTED.";
      }
    }

    batchList.addEventListener("click", async (e) => {
      const btn = e.target;
      const action = btn.dataset.action;
      const key = btn.dataset.key;
      if (!action || !key) return;

      const groups = groupByBatch();

      if (action === "view-batch") {
        if (!groups[key]) return;
        selectedBatchKey = key;
        renderSelectedBatchItems(key, groups[key]);
      } else if (action === "rename-batch") {
        if (!groups[key]) return;
        const items = groups[key];
        const currentName = (items[0].batchName || "").trim();
        const newName = prompt("ENTER BATCH NAME:", currentName);
        if (newName === null) return;

        const trimmed = newName.trim().toUpperCase();
        try {
          setStatus("UPDATING BATCH NAMEâ€¦");
          await loadInventory();
          const freshGroups = groupByBatch();
          const freshItems = freshGroups[key] || [];
          freshItems.forEach((it) => {
            it.batchName = trimmed;
          });
          await saveInventory();
          await loadInventory();
          setStatus("BATCH NAME UPDATED");
        } catch (err) {
          console.error("RENAME BATCH FAILED:", err);
          setStatus("ERROR RENAMING BATCH");
        }
      }
    });

    function renderSelectedBatchItems(batchKey, items) {
      batchItemsWrapper.style.display = "block";
      const first = items[0];
      const batchTime = getBatchTimeForItem(first) || batchKey;
      const batchName = (first.batchName || "").trim();
      const displayName = batchName || formatDate(batchTime);
      const statusRaw = first.batchStatus || "PENDING";
      const statusDisplay = getStatusDisplay(statusRaw);

      selectedBatchLabel.textContent = `BATCH: ${displayName} â€¢ DATE: ${formatDate(
        batchTime
      )} â€¢ ${items.length} ITEM(S) â€¢ STATUS: ${statusDisplay}`;

      adminBatchBody.innerHTML = "";
      items.forEach((item) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${item.id || "-"}</td>
          <td>${item.name || ""}</td>
          <td>${item.quantity ?? ""}</td>
          <td>${item.group || ""}</td>
          <td>${item.details || ""}</td>
          <td>${formatDate(item.updatedAt || item.timestamp)}</td>
          <td class="actions-cell">
            <button class="small secondary" data-action="edit-item" data-id="${item.id}">EDIT</button>
            <button class="small danger" data-action="delete-item" data-id="${item.id}">DELETE</button>
          </td>`;
        adminBatchBody.appendChild(tr);
      });
    }

    // APPROVE
    approveBatchBtn.addEventListener("click", async () => {
      if (!selectedBatchKey) {
        alert("NO BATCH SELECTED.");
        return;
      }

      const groups = groupByBatch();
      const items = groups[selectedBatchKey];
      if (!items || !items.length) {
        alert("BATCH HAS NO ITEMS.");
        return;
      }

      try {
        setStatus("APPROVING BATCHâ€¦");

        inventory.forEach((it) => {
          if (getBatchKeyForItem(it) === selectedBatchKey) it.batchStatus = "APPROVED";
        });
        await saveInventory();
        await loadInventory();

        const freshGroups = groupByBatch();
        const freshItems = freshGroups[selectedBatchKey] || [];
        const payload = {
          phone: ADMIN_PHONE,
          batchTime: getBatchTimeForItem(freshItems[0]) || selectedBatchKey,
          items: freshItems.map((it) => ({
            name: it.name,
            quantity: it.quantity,
            group: it.group,
            details: it.details
          }))
        };

        fetch(NOTIFY_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        }).catch((err) => console.error("NOTIFY FAILED:", err));

        setStatus("BATCH APPROVED");
      } catch (err) {
        console.error("APPROVE FAILED:", err);
        setStatus("ERROR APPROVING BATCH");
      }
    });

    // SEND WHATSAPP
    function buildBatchWhatsAppMessage(_batchTimeIso, items) {
      const lines = items.map((it) => {
        const parts = [
          (it.name || "").toString().toUpperCase(),
          String(it.quantity ?? ""),
          (it.group || "").toString().toUpperCase()
        ];
        return parts.join(", ");
      });
      return lines.join("\n");
    }

    function openWhatsAppForBatch(message) {
      const url = `https://wa.me/${WHATSAPP_PHONE}?text=${encodeURIComponent(message)}`;
      try {
        const win = window.open(url, "_blank");
        return !!win;
      } catch {
        return false;
      }
    }

    sendWhatsAppBtn.addEventListener("click", () => {
      if (!selectedBatchKey) {
        alert("NO BATCH SELECTED.");
        return;
      }

      const groups = groupByBatch();
      const items = groups[selectedBatchKey];
      if (!items || !items.length) {
        alert("BATCH HAS NO ITEMS.");
        return;
      }

      const first = items[0];
      const statusRaw = (first.batchStatus || "PENDING").toUpperCase();
      if (statusRaw !== "APPROVED") {
        alert("BATCH IS NOT APPROVED YET.");
        return;
      }

      const message = buildBatchWhatsAppMessage(null, items);
      const opened = openWhatsAppForBatch(message);
      if (!opened) alert("WHATSAPP MESSAGE (COPY & SEND):\n\n" + message);
    });

    // ADMIN TABLE ACTIONS
    adminBatchBody.addEventListener("click", handleAdminTableClick);
    inventoryBody.addEventListener("click", handleAdminTableClick);

    async function handleAdminTableClick(e) {
      const btn = e.target;
      const id = btn.dataset.id;
      if (!btn.dataset.action || !id) return;

      if (btn.dataset.action === "edit-item") {
        const item = inventory.find((it) => it.id === id);
        if (!item) {
          setStatus("ITEM NOT FOUND");
          return;
        }

        currentRole = "admin";
        updateRoleUI();

        adminEditId = id;
        itemNameInput.value = (item.name || "").toString().toUpperCase();
        itemQtyInput.value = item.quantity ?? "";
        itemGroupInput.value = (item.group || "").toString().toUpperCase();
        itemDetailsInput.value = (item.details || "").toString().toUpperCase();
        formImages = getImagesForItem(id).map((img) => ({ ...img }));
        renderFormImages();

        submitBtn.textContent = "UPDATE BATCH ITEM";
        cancelEditBtn.style.display = "inline-block";
        formTitle.textContent = "EDIT ITEM (ADMIN)";
        window.scrollTo({ top: 0, behavior: "smooth" });
      } else if (btn.dataset.action === "delete-item") {
        if (!confirm("DELETE THIS ITEM?")) return;

        try {
          setStatus("DELETING ITEMâ€¦");
          await loadInventory();
          await loadImages();

          const idx = inventory.findIndex((it) => it.id === id);
          if (idx === -1) {
            setStatus("ITEM NOT FOUND");
            return;
          }

          inventory.splice(idx, 1);
          imagesStore = imagesStore.filter((e) => e.itemId !== id);

          await saveInventory();
          await saveImages();
          await loadInventory();
          await loadImages();
          setStatus("ITEM DELETED");
        } catch (err) {
          console.error("DELETE FAILED:", err);
          setStatus("ERROR DELETING");
        }
      }
    }

    // FORM SUBMIT (staff + admin)
    itemForm.addEventListener("submit", async (e) => {
      e.preventDefault();

      const name = itemNameInput.value.trim().toUpperCase();
      const qty = Number(itemQtyInput.value || 0);
      const group = itemGroupInput.value.trim().toUpperCase();
      const details = itemDetailsInput.value.trim().toUpperCase();

      if (!name || Number.isNaN(qty)) {
        alert("NAME AND QUANTITY ARE REQUIRED.");
        return;
      }
      if (!formImages.length) {
        alert("AT LEAST 1 IMAGE IS REQUIRED.");
        return;
      }

      const now = new Date().toISOString();

      const baseItem = {
        id:
          batchEditIndex === null
            ? adminEditId || generateId()
            : batchItems[batchEditIndex].id,
        name,
        quantity: qty,
        group,
        details,
        timestamp:
          batchEditIndex === null
            ? now
            : batchItems[batchEditIndex].timestamp || now,
        updatedAt: now
      };

      if (currentRole === "admin" && adminEditId && batchEditIndex === null) {
        // Editing uploaded item
        try {
          setStatus("UPDATING ITEMâ€¦");
          await loadInventory();
          await loadImages();

          const idx = inventory.findIndex((it) => it.id === adminEditId);
          if (idx === -1) {
            setStatus("ITEM NOT FOUND");
            return;
          }

          inventory[idx] = {
            ...inventory[idx],
            name,
            quantity: qty,
            group,
            details,
            updatedAt: now
          };
          setImagesForItem(adminEditId, formImages.map((img) => ({ ...img })));

          await saveInventory();
          await saveImages();
          await loadInventory();
          await loadImages();
          resetForm();
          setStatus("ITEM UPDATED");
        } catch (err) {
          console.error("SAVE FAILED:", err);
          setStatus("ERROR SAVING");
        }
        return;
      }

      // BATCH ITEM
      const copyImages = formImages.map((img) => ({ ...img }));

      if (batchEditIndex === null) {
        batchItems.push({ ...baseItem, images: copyImages });
        setStatus("ITEM ADDED TO BATCH");
      } else {
        batchItems[batchEditIndex] = { ...baseItem, images: copyImages };
        setStatus("BATCH ITEM UPDATED");
      }

      renderBatch();
      resetForm();
    });

    cancelEditBtn.addEventListener("click", () => resetForm());

    // ADMIN LOGIN
    appTitle.addEventListener("click", () => {
      if (currentRole === "admin") {
        currentRole = "staff";
        resetForm();
        updateRoleUI();
        return;
      }

      const pwd = prompt("ENTER ADMIN PASSWORD:");
      if (!pwd) return;
      if (pwd !== ADMIN_PASSWORD) {
        alert("WRONG PASSWORD.");
        return;
      }

      currentRole = "admin";
      updateRoleUI();
      Promise.all([loadInventory(), loadImages()]);
    });

    // ADMIN MAIN TABS
    tabButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        setAdminMainTab(btn.dataset.tab);
      });
    });

    // BATCH FILTER TABS
    batchFilterButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        currentBatchFilter = btn.dataset.batchView || "pending";
        batchFilterButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        renderAdminViews();
      });
    });

    // BATCH SEARCH
    batchSearchBtn.addEventListener("click", () => {
      batchSearchName = (batchSearchNameInput.value || "").trim().toUpperCase();
      batchSearchDate = batchSearchDateInput.value || "";
      renderAdminViews();
    });

    batchClearSearchBtn.addEventListener("click", () => {
      batchSearchNameInput.value = "";
      batchSearchDateInput.value = "";
      batchSearchName = "";
      batchSearchDate = "";
      renderAdminViews();
    });

    // REPORT FILTERS
    itemSearchBtn.addEventListener("click", () => {
      itemSearchTerm = (itemSearchInput.value || "").trim().toUpperCase();
      reportDateFrom = reportDateFromInput.value || "";
      reportDateTo = reportDateToInput.value || "";
      reportGroupFilter = (reportGroupInput.value || "").trim().toUpperCase();
      reportStatusFilter = (reportStatusSelect.value || "ALL").toUpperCase();
      reportBatchNameFilter = (reportBatchInput.value || "").trim().toUpperCase();
      renderAdminViews();
    });

    itemClearSearchBtn.addEventListener("click", () => {
      itemSearchInput.value = "";
      reportDateFromInput.value = "";
      reportDateToInput.value = "";
      reportGroupInput.value = "";
      reportStatusSelect.value = "ALL";
      reportBatchInput.value = "";
      itemSearchTerm = "";
      reportDateFrom = "";
      reportDateTo = "";
      reportGroupFilter = "";
      reportStatusFilter = "ALL";
      reportBatchNameFilter = "";
      itemSearchResult.textContent = "";
      renderAdminViews();
    });

    // BELL CLICK
    pendingBadge.addEventListener("click", () => {
      if (currentRole !== "admin") return;
      setAdminMainTab("batches");
      currentBatchFilter = "pending";
      batchFilterButtons.forEach((b) => {
        b.classList.toggle("active", b.dataset.batchView === "pending");
      });
      renderAdminViews();
      adminCard.scrollIntoView({ behavior: "smooth" });
      playBellSound();
    });

    // INIT
    (async function init() {
      registerPWA();
      updateRoleUI();
      renderBatch();
      await loadInventory();
      await loadImages();
    })();
  </script>
</body>
</html>
