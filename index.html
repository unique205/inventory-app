<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>INVENTORY SYSTEM</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --card: #020617;
      --border: #1f2937;
      --accent: #4f46e5;
      --accent-soft: #6366f1;
      --danger: #b91c1c;
      --danger-soft: #dc2626;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text-main);
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.7rem 1rem;
      border-bottom: 1px solid var(--border);
      background: #020617;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    header h1 {
      margin: 0;
      font-size: 1.1rem;
      cursor: pointer;
      user-select: none;
    }

    .badge {
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid #4b5563;
      background: #111827;
    }

    .badge-staff {
      border-color: #3b82f6;
      color: #bfdbfe;
    }

    .badge-admin {
      border-color: #22c55e;
      color: #bbf7d0;
    }

    main {
      max-width: 1040px;
      margin: 1rem auto 2rem;
      padding: 0 0.75rem;
    }

    .card {
      background: var(--card);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.9rem 0.9rem 1.1rem;
      margin-bottom: 1rem;
    }

    .card h2 {
      margin: 0 0 0.6rem;
      font-size: 1rem;
    }

    label {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: block;
      margin-bottom: 0.15rem;
    }

    .field-row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0.6rem;
      margin-bottom: 0.6rem;
    }

    input,
    textarea,
    button {
      font: inherit;
      border-radius: 0.4rem;
      border: 1px solid #374151;
      background: #020617;
      color: var(--text-main);
      padding: 0.4rem 0.55rem;
    }

    input.upper,
    textarea.upper {
      text-transform: uppercase;
    }

    textarea {
      min-height: 50px;
      resize: vertical;
    }

    button {
      cursor: pointer;
      background: var(--accent);
      border-color: var(--accent);
      font-weight: 500;
      font-size: 0.85rem;
    }

    button:hover {
      background: var(--accent-soft);
    }

    button.secondary {
      background: #111827;
      border-color: #4b5563;
    }

    button.secondary:hover {
      background: #1f2937;
    }

    button.danger {
      background: var(--danger);
      border-color: var(--danger);
    }

    button.danger:hover {
      background: var(--danger-soft);
    }

    button.small {
      padding: 0.22rem 0.45rem;
      font-size: 0.7rem;
      margin-right: 0.25rem;
    }

    .actions-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.4rem;
    }

    .actions-row > button {
      flex: 0 0 auto;
    }

    .status {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .muted {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .table-wrapper {
      margin-top: 0.4rem;
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
      text-transform: uppercase;
    }

    th,
    td {
      padding: 0.35rem 0.35rem;
      border-bottom: 1px solid var(--border);
      text-align: left;
      white-space: nowrap;
    }

    th {
      background: #020617;
    }

    tr:hover td {
      background: #020617;
    }

    .batch-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.45rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border);
      margin-bottom: 0.4rem;
      font-size: 0.78rem;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .tab-row {
      display: flex;
      gap: 0.4rem;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
    }

    .tab-btn {
      background: #111827;
      border-color: #4b5563;
      font-size: 0.8rem;
      padding: 0.3rem 0.6rem;
    }

    .tab-btn.active {
      background: var(--accent);
      border-color: var(--accent);
    }

    /* Highlight for searched items */
    tr.highlight-row td {
      background: #111827;
      border-bottom-color: var(--accent-soft);
    }

    /* ===== SMALL SCREENS ===== */
    @media (max-width: 640px) {
      header {
        gap: 0.5rem;
      }

      header h1 {
        font-size: 1rem;
      }

      .actions-row {
        flex-direction: column;
        align-items: stretch;
      }

      .actions-row > button {
        width: 100%;
      }

      button.small {
        width: 100%;
        margin-right: 0;
      }

      /* Hide ID column on narrow screens */
      th:nth-child(1),
      td:nth-child(1) {
        display: none;
      }

      /* Actions column vertically stacked */
      td.actions-cell {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }
    }

    /* Wider screens: 2-column row for name/qty/group */
    @media (min-width: 641px) {
      .field-row {
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }
    }
  </style>
</head>
<body>
  <header>
    <h1 id="app-title">INVENTORY SYSTEM</h1>
    <span id="role-badge" class="badge badge-staff">STAFF</span>
  </header>

  <main>
    <!-- ADD / EDIT FORM -->
    <section class="card">
      <h2 id="form-title">ADD ITEM</h2>
      <form id="item-form">
        <div class="field-row">
          <div>
            <label for="item-name">ITEM NAME *</label>
            <input id="item-name" class="upper" list="name-list" autocomplete="off" required />
            <datalist id="name-list"></datalist>
          </div>
          <div>
            <label for="item-qty">QUANTITY *</label>
            <input id="item-qty" type="number" min="0" step="1" required />
          </div>
          <div>
            <label for="item-group">GROUP</label>
            <input id="item-group" class="upper" placeholder="E.G. RAW MATERIAL" />
          </div>
        </div>
        <div>
          <label for="item-details">DETAILS</label>
          <textarea id="item-details" class="upper" placeholder="GRADE, BRAND, ETC."></textarea>
        </div>
        <div class="actions-row">
          <button type="submit" id="submit-btn">ADD TO BATCH</button>
          <button type="button" id="cancel-edit-btn" class="secondary" style="display:none;">CANCEL</button>
          <div class="status">STATUS: <span id="status-text">IDLE</span></div>
        </div>
      </form>
    </section>

    <!-- CURRENT BATCH -->
    <section class="card">
      <h2>CURRENT BATCH (NOT UPLOADED)</h2>
      <p class="muted" id="batch-info">
        ADD ITEMS ABOVE. THEY WILL APPEAR HERE UNTIL YOU UPLOAD THE BATCH.
      </p>
      <div class="table-wrapper">
        <table>
          <thead>
            <tr>
              <th>ID</th>
              <th>NAME</th>
              <th>QTY</th>
              <th>GROUP</th>
              <th>DETAILS</th>
              <th>ACTIONS</th>
            </tr>
          </thead>
          <tbody id="batch-body"></tbody>
        </table>
      </div>
      <div class="actions-row" style="margin-top:0.6rem;">
        <button type="button" id="upload-batch-btn" class="secondary">UPLOAD BATCH</button>
        <span class="muted" id="batch-status"></span>
      </div>
    </section>

    <!-- ADMIN PANEL -->
    <section class="card" id="admin-card" style="display:none;">
      <h2>ADMIN PANEL</h2>
      <div class="tab-row">
        <button type="button" class="tab-btn active" data-tab="batches">BATCHES</button>
        <button type="button" class="tab-btn" data-tab="items">ALL ITEMS</button>
      </div>

      <!-- BATCH TAB -->
      <div id="admin-batches-tab">
        <div class="muted" id="batch-list-info">LOADINGâ€¦</div>

        <!-- Batch search controls -->
        <div class="field-row" style="margin:0.4rem 0;">
          <div>
            <label for="batch-search-name">SEARCH BATCH BY NAME</label>
            <input id="batch-search-name" placeholder="TYPE BATCH NAMEâ€¦" />
          </div>
          <div>
            <label for="batch-search-date">SEARCH BATCH BY DATE</label>
            <input id="batch-search-date" type="date" />
          </div>
        </div>
        <div class="actions-row" style="margin-top:0.2rem;">
          <button type="button" id="batch-search-btn" class="secondary small">SEARCH</button>
          <button type="button" id="batch-clear-search-btn" class="secondary small">CLEAR</button>
        </div>

        <div id="batch-list" style="margin-top:0.5rem;"></div>

        <div id="batch-items-wrapper" style="margin-top:0.7rem; display:none;">
          <div class="actions-row" style="margin-bottom:0.3rem;">
            <span class="muted" id="selected-batch-label">NO BATCH SELECTED.</span>
            <button type="button" id="approve-batch-btn" class="secondary">
              APPROVE
            </button>
            <button type="button" id="send-whatsapp-btn" class="secondary">
              SEND WHATSAPP
            </button>
          </div>
          <div class="table-wrapper">
            <table>
              <thead>
                <tr>
                  <th>ID</th>
                  <th>NAME</th>
                  <th>QTY</th>
                  <th>GROUP</th>
                  <th>DETAILS</th>
                  <th>UPDATED AT</th>
                  <th>ACTIONS</th>
                </tr>
              </thead>
              <tbody id="admin-batch-body"></tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- ITEMS TAB -->
      <div id="admin-items-tab" style="display:none;">
        <div class="muted" id="count-info">LOADINGâ€¦</div>

        <!-- Item search controls -->
        <div class="field-row" style="margin-top:0.4rem;">
          <div>
            <label for="item-search-input">SEARCH ITEM (NAME)</label>
            <input id="item-search-input" placeholder="TYPE ITEM NAMEâ€¦" class="upper" />
          </div>
        </div>
        <div class="actions-row" style="margin-top:0.2rem;">
          <button type="button" id="item-search-btn" class="secondary small">SEARCH</button>
          <button type="button" id="item-clear-search-btn" class="secondary small">CLEAR</button>
          <span class="muted" id="item-search-result"></span>
        </div>

        <div class="table-wrapper" style="margin-top:0.4rem;">
          <table>
            <thead>
              <tr>
                <th>ID</th>
                <th>NAME</th>
                <th>QTY</th>
                <th>GROUP</th>
                <th>DETAILS</th>
                <th>BATCH TIME</th>
                <th>UPDATED AT</th>
                <th>ACTIONS</th>
              </tr>
            </thead>
            <tbody id="inventory-body"></tbody>
          </table>
        </div>
      </div>
    </section>
  </main>

  <script>
    // ===== CONFIG =====
    const BACKEND_URL = "https://inventory-backend-s4sv.onrender.com/get-token";
    const NOTIFY_URL = "https://inventory-backend-s4sv.onrender.com/notify-batch";
    const REPO_OWNER = "unique205";
    const REPO_NAME = "inventory-data";
    const FILE_PATH = "data/inventory.json";
    const BRANCH = "main";
    const ADMIN_PASSWORD = "admin123";
    const ADMIN_PHONE = "917588756668"; // +91 7588756668
    const WHATSAPP_PHONE = ADMIN_PHONE; // used for wa.me

    // ===== STATE =====
    let currentRole = "staff";
    let inventory = [];
    let currentSha = null;
    let batchItems = [];
    let batchEditIndex = null;
    let adminEditId = null;
    let selectedBatchKey = null;

    // Search/filter state
    let batchSearchName = "";
    let batchSearchDate = "";
    let itemSearchTerm = "";

    // ===== DOM =====
    const appTitle = document.getElementById("app-title");
    const roleBadge = document.getElementById("role-badge");

    const itemForm = document.getElementById("item-form");
    const itemNameInput = document.getElementById("item-name");
    const itemQtyInput = document.getElementById("item-qty");
    const itemGroupInput = document.getElementById("item-group");
    const itemDetailsInput = document.getElementById("item-details");
    const submitBtn = document.getElementById("submit-btn");
    const cancelEditBtn = document.getElementById("cancel-edit-btn");
    const formTitle = document.getElementById("form-title");
    const statusText = document.getElementById("status-text");

    const batchBody = document.getElementById("batch-body");
    const uploadBatchBtn = document.getElementById("upload-batch-btn");
    const batchStatus = document.getElementById("batch-status");
    const nameList = document.getElementById("name-list");

    const adminCard = document.getElementById("admin-card");
    const tabButtons = document.querySelectorAll(".tab-btn");
    const adminBatchesTab = document.getElementById("admin-batches-tab");
    const adminItemsTab = document.getElementById("admin-items-tab");

    const batchListInfo = document.getElementById("batch-list-info");
    const batchList = document.getElementById("batch-list");
    const batchItemsWrapper = document.getElementById("batch-items-wrapper");
    const selectedBatchLabel = document.getElementById("selected-batch-label");
    const approveBatchBtn = document.getElementById("approve-batch-btn");
    const sendWhatsAppBtn = document.getElementById("send-whatsapp-btn");
    const adminBatchBody = document.getElementById("admin-batch-body");

    const countInfo = document.getElementById("count-info");
    const inventoryBody = document.getElementById("inventory-body");

    // Batch search DOM
    const batchSearchNameInput = document.getElementById("batch-search-name");
    const batchSearchDateInput = document.getElementById("batch-search-date");
    const batchSearchBtn = document.getElementById("batch-search-btn");
    const batchClearSearchBtn = document.getElementById("batch-clear-search-btn");

    // Item search DOM
    const itemSearchInput = document.getElementById("item-search-input");
    const itemSearchBtn = document.getElementById("item-search-btn");
    const itemClearSearchBtn = document.getElementById("item-clear-search-btn");
    const itemSearchResult = document.getElementById("item-search-result");

    // ===== UTILS =====
    function setStatus(msg) {
      statusText.textContent = msg.toUpperCase();
    }

    function generateId() {
      const ts = Date.now();
      const rand = Math.random().toString(36).substring(2, 8);
      return `ITEM_${ts}_${rand.toUpperCase()}`;
    }

    function generateBatchId() {
      const ts = Date.now();
      const rand = Math.random().toString(36).substring(2, 8).toUpperCase();
      return `BATCH_${ts}_${rand}`;
    }

    function formatDate(iso) {
      if (!iso) return "-";
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return String(iso).toUpperCase();
      return d.toLocaleString().toUpperCase();
    }

    function buildBatchWhatsAppMessage(batchTimeIso, items) {
      const headerLines = [
        "NEW INVENTORY BATCH",
        "TIME: " + formatDate(batchTimeIso),
        "",
      ];

      const itemLines = items.map((it, idx) => {
        const parts = [
          `${idx + 1}. ${it.name || ""}`,
          `QTY: ${it.quantity ?? ""}`,
        ];

        if (it.group) parts.push(`GROUP: ${it.group}`);
        if (it.details) parts.push(`DETAILS: ${it.details}`);

        return parts.join(" | ");
      });

      return [...headerLines, ...itemLines].join("\n");
    }

    function openWhatsAppForBatch(message) {
      const url = `https://wa.me/${WHATSAPP_PHONE}?text=${encodeURIComponent(message)}`;

      try {
        const win = window.open(url, "_blank");
        if (!win) {
          console.warn("WHATSAPP WINDOW BLOCKED OR NOT OPENED");
          return false;
        }
        return true;
      } catch (err) {
        console.error("FAILED TO OPEN WHATSAPP:", err);
        return false;
      }
    }

    function getBatchKeyForItem(item) {
      return item.batchId || item.batchTime || item.timestamp || "UNKNOWN";
    }

    function getBatchTimeForItem(item) {
      return item.batchTime || item.timestamp || null;
    }

    function getStatusDisplay(statusRaw) {
      const s = (statusRaw || "PENDING").toUpperCase();
      if (s === "APPROVED") return "âœ… APPROVED";
      return "ðŸŸ¡ PENDING";
    }

    function getBatchDisplayNameFromItems(batchKey, items) {
      if (!items || !items.length) return formatDate(batchKey);
      const first = items[0];
      const batchName = (first.batchName || "").trim();
      const batchTime = getBatchTimeForItem(first) || batchKey;
      if (batchName) return batchName;
      return formatDate(batchTime);
    }

    async function getBackendToken() {
      try {
        const res = await fetch(BACKEND_URL, { method: "POST" });
        if (!res.ok) {
          console.warn("BACKEND /get-token HTTP ERROR:", res.status);
          return null;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.token) {
          console.warn("BACKEND /get-token RETURNED NO TOKEN");
          return null;
        }
        return data.token;
      } catch (err) {
        console.error("BACKEND /get-token FAILED:", err);
        return null;
      }
    }

    async function githubRequest(path, options = {}) {
      const token = await getBackendToken();
      if (!token) {
        throw new Error("BACKEND TOKEN REQUEST FAILED");
      }

      const res = await fetch(`https://api.github.com${path}`, {
        ...options,
        headers: {
          "Authorization": `Bearer ${token}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json",
          ...(options.headers || {})
        }
      });

      if (!res.ok) {
        const text = await res.text();
        throw new Error(`GITHUB ERROR ${res.status}: ${text}`);
      }
      return res.json();
    }

    function resetForm() {
      itemNameInput.value = "";
      itemQtyInput.value = "";
      itemGroupInput.value = "";
      itemDetailsInput.value = "";
      batchEditIndex = null;
      adminEditId = null;

      if (currentRole === "admin") {
        submitBtn.textContent = "UPDATE ITEM";
        formTitle.textContent = "EDIT ITEM (ADMIN)";
      } else {
        submitBtn.textContent = "ADD TO BATCH";
        formTitle.textContent = "ADD ITEM";
      }
      cancelEditBtn.style.display = "none";
    }

    function updateRoleUI() {
      if (currentRole === "admin") {
        roleBadge.textContent = "ADMIN";
        roleBadge.className = "badge badge-admin";
        adminCard.style.display = "block";
      } else {
        roleBadge.textContent = "STAFF";
        roleBadge.className = "badge badge-staff";
        adminCard.style.display = "none";
      }
      renderBatch();
      renderAdminViews();
    }

    // ===== LOAD / SAVE INVENTORY =====
    async function loadInventory() {
      try {
        setStatus("LOADING FROM GITHUBâ€¦");
        const data = await githubRequest(
          `/repos/${REPO_OWNER}/${REPO_NAME}/contents/${encodeURIComponent(FILE_PATH)}?ref=${BRANCH}`
        );

        currentSha = data.sha;
        const decoded = atob(data.content.replace(/\n/g, ""));
        inventory = decoded.trim() ? JSON.parse(decoded) : [];

        populateNameList();
        renderAdminViews();
        setStatus("LOADED");
      } catch (err) {
        console.error("ERROR LOADING INVENTORY:", err);
        inventory = [];
        currentSha = null;
        populateNameList();
        renderAdminViews();
        setStatus("WORKING OFFLINE (INVENTORY NOT LOADED)");
      }
    }

    async function saveInventory() {
      const content = btoa(JSON.stringify(inventory, null, 2));
      const body = {
        message: "UPDATE INVENTORY.JSON FROM INVENTORY-APP",
        content,
        branch: BRANCH
      };
      if (currentSha) body.sha = currentSha;

      const data = await githubRequest(
        `/repos/${REPO_OWNER}/${REPO_NAME}/contents/${encodeURIComponent(FILE_PATH)}`,
        { method: "PUT", body: JSON.stringify(body) }
      );

      currentSha = data.content.sha;
    }

    function populateNameList() {
      const names = new Set();
      inventory.forEach((it) => {
        if (it.name) names.add(String(it.name).toUpperCase());
      });
      nameList.innerHTML = "";
      names.forEach((name) => {
        const opt = document.createElement("option");
        opt.value = name;
        nameList.appendChild(opt);
      });
    }

    // ===== BATCH (STAFF) =====
    function renderBatch() {
      batchBody.innerHTML = "";

      if (!batchItems.length) {
        batchBody.innerHTML =
          '<tr><td colspan="6" class="muted">NO ITEMS IN BATCH.</td></tr>';
      } else {
        batchItems.forEach((item, index) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${item.id}</td>
            <td>${item.name}</td>
            <td>${item.quantity}</td>
            <td>${item.group || ""}</td>
            <td>${item.details || ""}</td>
            <td class="actions-cell">
              <button class="small secondary" data-action="edit-batch" data-index="${index}">EDIT</button>
              <button class="small danger" data-action="remove-batch" data-index="${index}">REMOVE</button>
            </td>`;
          batchBody.appendChild(tr);
        });
      }
      // keep status text as is (set by upload / others)
    }

    batchBody.addEventListener("click", (e) => {
      const btn = e.target;
      if (!btn.dataset.action) return;
      const idx = Number(btn.dataset.index);

      if (btn.dataset.action === "edit-batch") {
        const item = batchItems[idx];
        batchEditIndex = idx;
        itemNameInput.value = item.name;
        itemQtyInput.value = item.quantity;
        itemGroupInput.value = item.group || "";
        itemDetailsInput.value = item.details || "";
        submitBtn.textContent = "UPDATE BATCH ITEM";
        cancelEditBtn.style.display = "inline-block";
        formTitle.textContent = "EDIT BATCH ITEM";
        window.scrollTo({ top: 0, behavior: "smooth" });
      } else if (btn.dataset.action === "remove-batch") {
        batchItems.splice(idx, 1);
        renderBatch();
      }
    });

    uploadBatchBtn.addEventListener("click", async () => {
      if (!batchItems.length) {
        batchStatus.textContent = "NO ITEMS IN BATCH.";
        return;
      }

      try {
        setStatus("UPLOADING BATCHâ€¦");
        batchStatus.textContent = "UPLOADINGâ€¦";

        const batchTime = new Date().toISOString();
        const batchId = generateBatchId();

        await loadInventory();

        const enriched = batchItems.map((item) => ({
          ...item,
          batchId,
          batchTime,
          batchStatus: "PENDING",
          batchName: item.batchName || ""
        }));

        inventory = inventory.concat(enriched);
        await saveInventory();
        await loadInventory();

        // STAFF DOES NOT SEND WHATSAPP â€“ ONLY ADMIN AFTER APPROVAL

        batchItems = [];
        renderBatch();
        batchStatus.textContent =
          "BATCH UPLOADED AT " + formatDate(batchTime);
        setStatus("BATCH UPLOADED");
      } catch (err) {
        console.error("BATCH UPLOAD FAILED:", err);
        batchStatus.textContent = "ERROR UPLOADING BATCH.";
        setStatus("ERROR UPLOADING");
      }
    });

    // ===== ADMIN VIEWS =====
    function groupByBatch() {
      const groups = {};
      inventory.forEach((item) => {
        const key = getBatchKeyForItem(item);
        if (!groups[key]) groups[key] = [];
        groups[key].push(item);
      });
      return groups;
    }

    function renderAdminViews() {
      if (currentRole !== "admin") return;

      const groups = groupByBatch();
      const keys = Object.keys(groups).sort((a, b) => {
        const ia = groups[a][0];
        const ib = groups[b][0];
        const ta = getBatchTimeForItem(ia) || "";
        const tb = getBatchTimeForItem(ib) || "";
        const da = new Date(ta);
        const db = new Date(tb);
        if (isNaN(da) || isNaN(db)) return 0;
        return db - da;
      });

      // BATCH LIST TAB â€“ split into PENDING / APPROVED
      batchList.innerHTML = "";

      const pendingContainer = document.createElement("div");
      const approvedContainer = document.createElement("div");

      const pendingHeader = document.createElement("div");
      pendingHeader.className = "muted";
      pendingHeader.style.marginBottom = "0.25rem";
      pendingHeader.textContent = "PENDING BATCHES";

      const approvedHeader = document.createElement("div");
      approvedHeader.className = "muted";
      approvedHeader.style.margin = "0.75rem 0 0.25rem";
      approvedHeader.textContent = "APPROVED BATCHES";

      pendingContainer.appendChild(pendingHeader);
      approvedContainer.appendChild(approvedHeader);

      let pendingCount = 0;
      let approvedCount = 0;

      keys.forEach((k) => {
        const items = groups[k];
        const first = items[0];
        const batchTime = getBatchTimeForItem(first) || k;
        const batchName = (first.batchName || "").trim();
        const displayName = batchName || formatDate(batchTime);
        const statusRaw = (first.batchStatus || "PENDING").toUpperCase();
        const statusDisplay = getStatusDisplay(statusRaw);

        // Filter by search
        const nameFilter = batchSearchName;
        const dateFilter = batchSearchDate;
        const dateStr = (() => {
          const d = new Date(batchTime);
          if (isNaN(d)) return "";
          return d.toISOString().slice(0, 10);
        })();

        if (nameFilter && !displayName.toUpperCase().includes(nameFilter)) {
          return;
        }
        if (dateFilter && dateStr !== dateFilter) {
          return;
        }

        const div = document.createElement("div");
        div.className = "batch-header";
        div.innerHTML = `
          <span>BATCH: ${displayName}</span>
          <span>DATE: ${formatDate(batchTime)}</span>
          <span>ITEMS: ${items.length}</span>
          <span>STATUS: ${statusDisplay}</span>
          <span>
            <button class="small secondary" data-action="view-batch" data-key="${k}">VIEW</button>
            <button class="small secondary" data-action="rename-batch" data-key="${k}">RENAME</button>
          </span>`;

        if (statusRaw === "APPROVED") {
          approvedContainer.appendChild(div);
          approvedCount++;
        } else {
          pendingContainer.appendChild(div);
          pendingCount++;
        }
      });

      if (pendingCount === 0) {
        const msg = document.createElement("div");
        msg.className = "muted";
        msg.textContent = "NO PENDING BATCHES.";
        pendingContainer.appendChild(msg);
      }

      if (approvedCount === 0) {
        const msg = document.createElement("div");
        msg.className = "muted";
        msg.textContent = "NO APPROVED BATCHES.";
        approvedContainer.appendChild(msg);
      }

      batchList.appendChild(pendingContainer);
      batchList.appendChild(approvedContainer);

      if (!keys.length) {
        batchListInfo.textContent = "NO BATCHES FOUND.";
      } else {
        batchListInfo.textContent = `${pendingCount} PENDING â€¢ ${approvedCount} APPROVED (FILTERED)`;
      }

      // ALL ITEMS TAB
      inventoryBody.innerHTML = "";
      if (!inventory.length) {
        countInfo.textContent = "NO ITEMS IN INVENTORY.";
        inventoryBody.innerHTML =
          '<tr><td colspan="8" class="muted">NO ITEMS.</td></tr>';
        itemSearchResult.textContent = "";
      } else {
        countInfo.textContent = `${inventory.length} ITEMS`;

        let matchCount = 0;
        let firstMatchInfo = null;

        inventory.forEach((item) => {
          const nameStr = (item.name || "").toString().toUpperCase();
          const matches = itemSearchTerm && nameStr.includes(itemSearchTerm);

          if (matches) {
            matchCount++;
            if (!firstMatchInfo) {
              const batchKey = getBatchKeyForItem(item);
              const batchTime = getBatchTimeForItem(item) || batchKey;
              const batchLabel = (item.batchName && item.batchName.trim())
                ? item.batchName
                : formatDate(batchTime);
              const statusRaw = item.batchStatus || "PENDING";
              const statusDisplay = getStatusDisplay(statusRaw);
              firstMatchInfo = {
                name: item.name,
                batchLabel,
                statusDisplay
              };
            }
          }

          const tr = document.createElement("tr");
          if (matches) {
            tr.classList.add("highlight-row");
          }
          tr.innerHTML = `
            <td>${item.id || "-"}</td>
            <td>${item.name || ""}</td>
            <td>${item.quantity ?? ""}</td>
            <td>${item.group || ""}</td>
            <td>${item.details || ""}</td>
            <td>${formatDate(item.batchTime || item.timestamp)}</td>
            <td>${formatDate(item.updatedAt || item.timestamp)}</td>
            <td class="actions-cell">
              <button class="small secondary" data-action="edit-item" data-id="${item.id}">EDIT</button>
              <button class="small danger" data-action="delete-item" data-id="${item.id}">DELETE</button>
            </td>`;
          inventoryBody.appendChild(tr);
        });

        if (itemSearchTerm && matchCount > 0 && firstMatchInfo) {
          itemSearchResult.textContent =
            `'${firstMatchInfo.name}' FOUND IN BATCH: ${firstMatchInfo.batchLabel} â€¢ STATUS: ${firstMatchInfo.statusDisplay}`;
        } else if (itemSearchTerm) {
          itemSearchResult.textContent = "NO ITEMS FOUND FOR SEARCH.";
        } else {
          itemSearchResult.textContent = "";
        }
      }

      if (selectedBatchKey && groups[selectedBatchKey]) {
        renderSelectedBatchItems(selectedBatchKey, groups[selectedBatchKey]);
      } else {
        batchItemsWrapper.style.display = "none";
        selectedBatchLabel.textContent = "NO BATCH SELECTED.";
      }
    }

    batchList.addEventListener("click", async (e) => {
      const btn = e.target;
      const action = btn.dataset.action;
      const key = btn.dataset.key;
      if (!action || !key) return;

      const groups = groupByBatch();

      if (action === "view-batch") {
        if (!groups[key]) return;
        selectedBatchKey = key;
        renderSelectedBatchItems(key, groups[key]);
      } else if (action === "rename-batch") {
        if (!groups[key]) return;
        const items = groups[key];
        const currentName = (items[0].batchName || "").trim();
        const newName = prompt("ENTER BATCH NAME:", currentName);
        if (newName === null) return;

        const trimmed = newName.trim().toUpperCase();
        try {
          setStatus("UPDATING BATCH NAMEâ€¦");
          await loadInventory();
          const freshGroups = groupByBatch();
          const freshItems = freshGroups[key] || [];
          freshItems.forEach((it) => {
            it.batchName = trimmed;
          });
          await saveInventory();
          await loadInventory();
          setStatus("BATCH NAME UPDATED");
        } catch (err) {
          console.error("RENAME BATCH FAILED:", err);
          setStatus("ERROR RENAMING BATCH");
        }
      }
    });

    function renderSelectedBatchItems(batchKey, items) {
      batchItemsWrapper.style.display = "block";
      const first = items[0];
      const batchTime = getBatchTimeForItem(first) || batchKey;
      const batchName = (first.batchName || "").trim();
      const displayName = batchName || formatDate(batchTime);
      const statusRaw = first.batchStatus || "PENDING";
      const statusDisplay = getStatusDisplay(statusRaw);

      selectedBatchLabel.textContent = `BATCH: ${displayName} â€¢ DATE: ${formatDate(
        batchTime
      )} â€¢ ${items.length} ITEM(S) â€¢ STATUS: ${statusDisplay}`;

      adminBatchBody.innerHTML = "";
      items.forEach((item) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${item.id || "-"}</td>
          <td>${item.name || ""}</td>
          <td>${item.quantity ?? ""}</td>
          <td>${item.group || ""}</td>
          <td>${item.details || ""}</td>
          <td>${formatDate(item.updatedAt || item.timestamp)}</td>
          <td class="actions-cell">
            <button class="small secondary" data-action="edit-item" data-id="${item.id}">EDIT</button>
            <button class="small danger" data-action="delete-item" data-id="${item.id}">DELETE</button>
          </td>`;
        adminBatchBody.appendChild(tr);
      });
    }

    // APPROVE (ADMIN ONLY)
    approveBatchBtn.addEventListener("click", async () => {
      if (!selectedBatchKey) {
        alert("NO BATCH SELECTED.");
        return;
      }

      const groups = groupByBatch();
      const items = groups[selectedBatchKey];
      if (!items || !items.length) {
        alert("BATCH HAS NO ITEMS.");
        return;
      }

      try {
        setStatus("APPROVING BATCHâ€¦");

        inventory.forEach((it) => {
          if (getBatchKeyForItem(it) === selectedBatchKey) it.batchStatus = "APPROVED";
        });
        await saveInventory();
        await loadInventory();

        // Also call backend stub (if needed)
        const freshGroups = groupByBatch();
        const freshItems = freshGroups[selectedBatchKey] || [];
        const payload = {
          phone: ADMIN_PHONE,
          batchTime: getBatchTimeForItem(freshItems[0]) || selectedBatchKey,
          items: freshItems.map((it) => ({
            name: it.name,
            quantity: it.quantity,
            group: it.group,
            details: it.details
          }))
        };

        fetch(NOTIFY_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        }).catch((err) => console.error("NOTIFY FAILED:", err));

        setStatus("BATCH APPROVED");
      } catch (err) {
        console.error("APPROVE FAILED:", err);
        setStatus("ERROR APPROVING BATCH");
      }
    });

    // SEND WHATSAPP (ADMIN ONLY, AFTER APPROVAL)
    sendWhatsAppBtn.addEventListener("click", () => {
      if (!selectedBatchKey) {
        alert("NO BATCH SELECTED.");
        return;
      }

      const groups = groupByBatch();
      const items = groups[selectedBatchKey];
      if (!items || !items.length) {
        alert("BATCH HAS NO ITEMS.");
        return;
      }

      const first = items[0];
      const statusRaw = (first.batchStatus || "PENDING").toUpperCase();
      if (statusRaw !== "APPROVED") {
        alert("BATCH IS NOT APPROVED YET.");
        return;
      }

      const batchTime = getBatchTimeForItem(first) || selectedBatchKey;
      const message = buildBatchWhatsAppMessage(batchTime, items);
      const opened = openWhatsAppForBatch(message);
      if (!opened) {
        alert("WHATSAPP MESSAGE (COPY & SEND):\n\n" + message);
      }
    });

    // ADMIN TABLE ACTIONS
    adminBatchBody.addEventListener("click", handleAdminTableClick);
    inventoryBody.addEventListener("click", handleAdminTableClick);

    async function handleAdminTableClick(e) {
      const btn = e.target;
      const id = btn.dataset.id;
      if (!btn.dataset.action || !id) return;

      if (btn.dataset.action === "edit-item") {
        const item = inventory.find((it) => it.id === id);
        if (!item) {
          setStatus("ITEM NOT FOUND");
          return;
        }

        currentRole = "admin";
        updateRoleUI();

        adminEditId = id;
        itemNameInput.value = (item.name || "").toUpperCase();
        itemQtyInput.value = item.quantity ?? "";
        itemGroupInput.value = (item.group || "").toUpperCase();
        itemDetailsInput.value = (item.details || "").toUpperCase();
        submitBtn.textContent = "UPDATE ITEM";
        cancelEditBtn.style.display = "inline-block";
        formTitle.textContent = "EDIT ITEM (ADMIN)";
        window.scrollTo({ top: 0, behavior: "smooth" });
      } else if (btn.dataset.action === "delete-item") {
        if (!confirm("DELETE THIS ITEM?")) return;

        try {
          setStatus("DELETING ITEMâ€¦");
          await loadInventory();

          const idx = inventory.findIndex((it) => it.id === id);
          if (idx === -1) {
            setStatus("ITEM NOT FOUND");
            return;
          }

          inventory.splice(idx, 1);
          await saveInventory();
          await loadInventory();
          setStatus("ITEM DELETED");
        } catch (err) {
          console.error("DELETE FAILED:", err);
          setStatus("ERROR DELETING");
        }
      }
    }

    // FORM SUBMIT
    itemForm.addEventListener("submit", async (e) => {
      e.preventDefault();

      const name = itemNameInput.value.trim().toUpperCase();
      const qty = Number(itemQtyInput.value || 0);
      const group = itemGroupInput.value.trim().toUpperCase();
      const details = itemDetailsInput.value.trim().toUpperCase();

      if (!name || Number.isNaN(qty)) {
        alert("NAME AND QUANTITY ARE REQUIRED.");
        return;
      }

      const now = new Date().toISOString();

      if (currentRole === "staff") {
        const baseItem = {
          id:
            batchEditIndex === null
              ? generateId()
              : batchItems[batchEditIndex].id,
          name,
          quantity: qty,
          group,
          details,
          timestamp:
            batchEditIndex === null
              ? now
              : batchItems[batchEditIndex].timestamp || now,
          updatedAt: now
        };

        if (batchEditIndex === null) {
          batchItems.push(baseItem);
          setStatus("ITEM ADDED TO BATCH");
        } else {
          batchItems[batchEditIndex] = baseItem;
          setStatus("BATCH ITEM UPDATED");
        }

        renderBatch();
        resetForm();
        return;
      }

      if (currentRole === "admin") {
        if (!adminEditId) {
          setStatus("SELECT AN ITEM FROM ADMIN TABLE");
          return;
        }

        try {
          setStatus("UPDATING ITEMâ€¦");
          await loadInventory();

          const idx = inventory.findIndex((it) => it.id === adminEditId);
          if (idx === -1) {
            setStatus("ITEM NOT FOUND");
            return;
          }

          inventory[idx] = {
            ...inventory[idx],
            name,
            quantity: qty,
            group,
            details,
            updatedAt: now
          };

          await saveInventory();
          await loadInventory();
          resetForm();
          setStatus("ITEM UPDATED");
        } catch (err) {
          console.error("SAVE FAILED:", err);
          setStatus("ERROR SAVING");
        }
      }
    });

    cancelEditBtn.addEventListener("click", () => resetForm());

    // ADMIN LOGIN VIA TITLE
    appTitle.addEventListener("click", () => {
      if (currentRole === "admin") {
        currentRole = "staff";
        resetForm();
        updateRoleUI();
        return;
      }

      const pwd = prompt("ENTER ADMIN PASSWORD:");
      if (!pwd) return;
      if (pwd !== ADMIN_PASSWORD) {
        alert("WRONG PASSWORD.");
        return;
      }

      currentRole = "admin";
      updateRoleUI();
      loadInventory();
    });

    // TABS
    tabButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        tabButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        const tab = btn.dataset.tab;
        if (tab === "batches") {
          adminBatchesTab.style.display = "block";
          adminItemsTab.style.display = "none";
        } else {
          adminBatchesTab.style.display = "none";
          adminItemsTab.style.display = "block";
        }
      });
    });

    // BATCH SEARCH EVENTS
    batchSearchBtn.addEventListener("click", () => {
      batchSearchName = (batchSearchNameInput.value || "").trim().toUpperCase();
      batchSearchDate = batchSearchDateInput.value || "";
      renderAdminViews();
    });

    batchClearSearchBtn.addEventListener("click", () => {
      batchSearchNameInput.value = "";
      batchSearchDateInput.value = "";
      batchSearchName = "";
      batchSearchDate = "";
      renderAdminViews();
    });

    // ITEM SEARCH EVENTS
    itemSearchBtn.addEventListener("click", () => {
      itemSearchTerm = (itemSearchInput.value || "").trim().toUpperCase();
      renderAdminViews();
    });

    itemClearSearchBtn.addEventListener("click", () => {
      itemSearchInput.value = "";
      itemSearchTerm = "";
      itemSearchResult.textContent = "";
      renderAdminViews();
    });

    // INIT
    (async function init() {
      updateRoleUI();
      renderBatch();
      await loadInventory();
    })();
  </script>
</body>
</html>
