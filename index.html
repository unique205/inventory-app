<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>INVENTORY SYSTEM</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --card: #020617;
      --border: #1f2937;
      --accent: #4f46e5;
      --accent-soft: #6366f1;
      --danger: #b91c1c;
      --danger-soft: #dc2626;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text-main);
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.7rem 1rem;
      border-bottom: 1px solid var(--border);
      background: #020617;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    header h1 {
      margin: 0;
      font-size: 1.1rem;
      cursor: pointer;
      user-select: none;
    }

    .badge {
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      font-size: 0.7rem;
      border: 1px solid #4b5563;
      background: #111827;
    }

    .badge-staff {
      border-color: #3b82f6;
      color: #bfdbfe;
    }

    .badge-admin {
      border-color: #22c55e;
      color: #bbf7d0;
    }

    main {
      max-width: 1040px;
      margin: 1rem auto 2rem;
      padding: 0 0.75rem;
    }

    .card {
      background: var(--card);
      border-radius: 0.75rem;
      border: 1px solid var(--border);
      padding: 0.9rem 0.9rem 1.1rem;
      margin-bottom: 1rem;
    }

    .card h2 {
      margin: 0 0 0.6rem;
      font-size: 1rem;
    }

    label {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: block;
      margin-bottom: 0.15rem;
    }

    .field-row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0.6rem;
      margin-bottom: 0.6rem;
    }

    input,
    textarea,
    button {
      font: inherit;
      border-radius: 0.4rem;
      border: 1px solid #374151;
      background: #020617;
      color: var(--text-main);
      padding: 0.4rem 0.55rem;
    }

    input.upper,
    textarea.upper {
      text-transform: uppercase;
    }

    textarea {
      min-height: 50px;
      resize: vertical;
    }

    button {
      cursor: pointer;
      background: var(--accent);
      border-color: var(--accent);
      font-weight: 500;
      font-size: 0.85rem;
    }

    button:hover {
      background: var(--accent-soft);
    }

    button.secondary {
      background: #111827;
      border-color: #4b5563;
    }

    button.secondary:hover {
      background: #1f2937;
    }

    button.danger {
      background: var(--danger);
      border-color: var(--danger);
    }

    button.danger:hover {
      background: var(--danger-soft);
    }

    button.small {
      padding: 0.22rem 0.45rem;
      font-size: 0.7rem;
      margin-right: 0.25rem;
    }

    .actions-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.4rem;
    }

    .actions-row > button {
      flex: 0 0 auto;
    }

    .status {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .muted {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .table-wrapper {
      margin-top: 0.4rem;
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
      text-transform: uppercase;
    }

    th,
    td {
      padding: 0.35rem 0.35rem;
      border-bottom: 1px solid var(--border);
      text-align: left;
      white-space: nowrap;
    }

    th {
      background: #020617;
    }

    tr:hover td {
      background: #020617;
    }

    .batch-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.45rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid var(--border);
      margin-bottom: 0.4rem;
      font-size: 0.78rem;
      gap: 0.5rem;
      flex-wrap: wrap;
    }

    .tab-row {
      display: flex;
      gap: 0.4rem;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
    }

    .tab-btn {
      background: #111827;
      border-color: #4b5563;
      font-size: 0.8rem;
      padding: 0.3rem 0.6rem;
    }

    .tab-btn.active {
      background: var(--accent);
      border-color: var(--accent);
    }

    /* Highlight for searched items */
    tr.highlight-row td {
      background: #111827;
      border-bottom-color: var(--accent-soft);
    }

    /* Item name suggestions (staff/admin add form) */
    .name-input-wrapper {
      position: relative;
    }

    .suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #020617;
      border: 1px solid #374151;
      border-radius: 0.4rem;
      margin-top: 0.15rem;
      max-height: 160px;
      overflow-y: auto;
      font-size: 0.75rem;
      display: none;
      z-index: 20;
    }

    .suggestion-item {
      padding: 0.25rem 0.45rem;
      cursor: pointer;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .suggestion-item:hover {
      background: #111827;
    }

    /* Bell animation */
    #pending-badge.bell-alert {
      border-color: #f97316;
      color: #fecaca;
      box-shadow: 0 0 10px #f97316;
      animation: bellRing 0.9s infinite;
    }

    @keyframes bellRing {
      0% { transform: translateX(0) rotate(0); }
      20% { transform: translateX(-1px) rotate(-5deg); }
      40% { transform: translateX(1px) rotate(5deg); }
      60% { transform: translateX(-1px) rotate(-5deg); }
      80% { transform: translateX(1px) rotate(5deg); }
      100% { transform: translateX(0) rotate(0); }
    }

    /* ===== SMALL SCREENS ===== */
    @media (max-width: 640px) {
      header {
        gap: 0.5rem;
      }

      header h1 {
        font-size: 1rem;
      }

      .actions-row {
        flex-direction: column;
        align-items: stretch;
      }

      .actions-row > button {
        width: 100%;
      }

      button.small {
        width: 100%;
        margin-right: 0;
      }

      /* Hide ID column on narrow screens */
      th:nth-child(1),
      td:nth-child(1) {
        display: none;
      }

      /* Actions column vertically stacked */
      td.actions-cell {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }
    }

    /* Wider screens: 2-column row for name/qty/group */
    @media (min-width: 641px) {
      .field-row {
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      }
    }
  </style>
</head>
<body>
  <header>
    <h1 id="app-title">INVENTORY SYSTEM</h1>
    <span id="role-badge" class="badge badge-staff">STAFF</span>
  </header>

  <main>
    <!-- STAFF ADD + BATCH (this will move into admin panel when admin logs in) -->
    <div id="staff-batch-wrapper">
      <!-- ADD / EDIT FORM -->
      <section class="card">
        <h2 id="form-title">ADD ITEM</h2>
        <form id="item-form">
          <div class="field-row">
            <div>
              <label for="item-name">ITEM NAME *</label>
              <div class="name-input-wrapper">
                <input id="item-name" class="upper" autocomplete="off" required />
                <div id="item-suggestions" class="suggestions"></div>
              </div>
            </div>
            <div>
              <label for="item-qty">QUANTITY *</label>
              <input id="item-qty" type="number" min="0" step="1" required />
            </div>
            <div>
              <label for="item-group">GROUP</label>
              <input id="item-group" class="upper" placeholder="E.G. RAW MATERIAL" />
            </div>
          </div>
          <div>
            <label for="item-details">DETAILS</label>
            <textarea id="item-details" class="upper" placeholder="GRADE, BRAND, ETC."></textarea>
          </div>
          <div class="actions-row">
            <button type="submit" id="submit-btn">ADD TO BATCH</button>
            <button type="button" id="cancel-edit-btn" class="secondary" style="display:none;">CANCEL</button>
            <div class="status">STATUS: <span id="status-text">IDLE</span></div>
          </div>
        </form>
      </section>

      <!-- CURRENT BATCH -->
      <section class="card">
        <h2>CURRENT BATCH (NOT UPLOADED)</h2>
        <p class="muted" id="batch-info">
          ADD ITEMS ABOVE. THEY WILL APPEAR HERE UNTIL YOU UPLOAD THE BATCH.
        </p>
        <div class="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>ID</th>
                <th>NAME</th>
                <th>QTY</th>
                <th>GROUP</th>
                <th>DETAILS</th>
                <th>ACTIONS</th>
              </tr>
            </thead>
            <tbody id="batch-body"></tbody>
          </table>
        </div>
        <div class="actions-row" style="margin-top:0.6rem;">
          <button type="button" id="upload-batch-btn" class="secondary">UPLOAD BATCH</button>
          <span class="muted" id="batch-status"></span>
        </div>
      </section>
    </div>

    <!-- ADMIN PANEL -->
    <section class="card" id="admin-card" style="display:none;">
      <h2>
        ADMIN PANEL
        <span id="pending-badge" class="badge">ðŸ”” 0</span>
      </h2>

      <!-- MAIN ADMIN TABS -->
      <div class="tab-row">
        <button type="button" class="tab-btn admin-main-tab" data-tab="add">ADD ITEMS</button>
        <button type="button" class="tab-btn admin-main-tab active" data-tab="batches">BATCHES</button>
        <button type="button" class="tab-btn admin-main-tab" data-tab="items">ALL ITEMS</button>
      </div>

      <!-- ADMIN ADD ITEMS TAB (reuses staff add+batch UI) -->
      <div id="admin-add-tab" style="display:none;">
        <div id="admin-add-container"></div>
      </div>

      <!-- ADMIN BATCHES TAB -->
      <div id="admin-batches-tab">
        <!-- Pending / Approved mini-tabs -->
        <div class="tab-row" id="batch-status-tabs" style="margin-bottom:0.4rem;">
          <button type="button" class="tab-btn small batch-filter-tab active" data-batch-view="pending">PENDING</button>
          <button type="button" class="tab-btn small batch-filter-tab" data-batch-view="approved">APPROVED</button>
        </div>

        <!-- Selected batch details (opens above list) -->
        <div id="batch-items-wrapper" style="margin-top:0.3rem; display:none;">
          <div class="actions-row" style="margin-bottom:0.3rem;">
            <span class="muted" id="selected-batch-label">NO BATCH SELECTED.</span>
            <button type="button" id="approve-batch-btn" class="secondary">
              APPROVE
            </button>
            <button type="button" id="send-whatsapp-btn" class="secondary">
              SEND WHATSAPP
            </button>
          </div>
          <div class="table-wrapper">
            <table>
              <thead>
                <tr>
                  <th>ID</th>
                  <th>NAME</th>
                  <th>QTY</th>
                  <th>GROUP</th>
                  <th>DETAILS</th>
                  <th>UPDATED AT</th>
                  <th>ACTIONS</th>
                </tr>
              </thead>
              <tbody id="admin-batch-body"></tbody>
            </table>
          </div>
        </div>

        <!-- Batch list -->
        <div class="muted" id="batch-list-info" style="margin-top:0.6rem;">LOADINGâ€¦</div>

        <!-- Batch search controls -->
        <div class="field-row" style="margin:0.4rem 0;">
          <div>
            <label for="batch-search-name">SEARCH BATCH BY NAME</label>
            <input id="batch-search-name" placeholder="TYPE BATCH NAMEâ€¦" />
          </div>
          <div>
            <label for="batch-search-date">SEARCH BATCH BY DATE</label>
            <input id="batch-search-date" type="date" />
          </div>
        </div>
        <div class="actions-row" style="margin-top:0.2rem;">
          <button type="button" id="batch-search-btn" class="secondary small">SEARCH</button>
          <button type="button" id="batch-clear-search-btn" class="secondary small">CLEAR</button>
        </div>

        <div id="batch-list" style="margin-top:0.4rem;"></div>
      </div>

      <!-- ADMIN ALL ITEMS TAB -->
      <div id="admin-items-tab" style="display:none;">
        <div class="muted" id="count-info">LOADINGâ€¦</div>

        <!-- Item search controls -->
        <div class="field-row" style="margin-top:0.4rem;">
          <div>
            <label for="item-search-input">SEARCH ITEM (NAME)</label>
            <input id="item-search-input" placeholder="TYPE ITEM NAMEâ€¦" class="upper" />
          </div>
        </div>
        <div class="actions-row" style="margin-top:0.2rem;">
          <button type="button" id="item-search-btn" class="secondary small">SEARCH</button>
          <button type="button" id="item-clear-search-btn" class="secondary small">CLEAR</button>
          <span class="muted" id="item-search-result"></span>
        </div>

        <div class="table-wrapper" style="margin-top:0.4rem;">
          <table>
            <thead>
              <tr>
                <th>ID</th>
                <th>NAME</th>
                <th>QTY</th>
                <th>GROUP</th>
                <th>DETAILS</th>
                <th>BATCH TIME</th>
                <th>UPDATED AT</th>
                <th>ACTIONS</th>
              </tr>
            </thead>
            <tbody id="inventory-body"></tbody>
          </table>
        </div>
      </div>
    </section>
  </main>

  <script>
    // ===== CONFIG =====
    const BACKEND_URL = "https://inventory-backend-s4sv.onrender.com/get-token";
    const NOTIFY_URL = "https://inventory-backend-s4sv.onrender.com/notify-batch";
    const REPO_OWNER = "unique205";
    const REPO_NAME = "inventory-data";
    const FILE_PATH = "data/inventory.json";
    const BRANCH = "main";
    const ADMIN_PASSWORD = "admin123";
    const ADMIN_PHONE = "917588756668"; // +91 7588756668
    const WHATSAPP_PHONE = ADMIN_PHONE; // used for wa.me

    // ===== STATE =====
    let currentRole = "staff";
    let inventory = [];
    let currentSha = null;
    let batchItems = [];
    let batchEditIndex = null;
    let adminEditId = null;
    let selectedBatchKey = null;

    // Search/filter state
    let batchSearchName = "";
    let batchSearchDate = "";
    let itemSearchTerm = "";
    let currentBatchFilter = "pending"; // "pending" or "approved"

    // ===== DOM =====
    const appTitle = document.getElementById("app-title");
    const roleBadge = document.getElementById("role-badge");

    const mainEl = document.querySelector("main");
    const staffBatchWrapper = document.getElementById("staff-batch-wrapper");

    // Staff/admin shared add form
    const itemForm = document.getElementById("item-form");
    const itemNameInput = document.getElementById("item-name");
    const itemQtyInput = document.getElementById("item-qty");
    const itemGroupInput = document.getElementById("item-group");
    const itemDetailsInput = document.getElementById("item-details");
    const submitBtn = document.getElementById("submit-btn");
    const cancelEditBtn = document.getElementById("cancel-edit-btn");
    const formTitle = document.getElementById("form-title");
    const statusText = document.getElementById("status-text");

    const nameInputWrapper = document.querySelector(".name-input-wrapper");
    const itemSuggestions = document.getElementById("item-suggestions");

    // Shared batch view (used by staff & admin ADD tab)
    const batchBody = document.getElementById("batch-body");
    const uploadBatchBtn = document.getElementById("upload-batch-btn");
    const batchStatus = document.getElementById("batch-status");

    // Admin general
    const adminCard = document.getElementById("admin-card");
    const pendingBadge = document.getElementById("pending-badge");
    const adminAddTab = document.getElementById("admin-add-tab");
    const adminAddContainer = document.getElementById("admin-add-container");
    const adminBatchesTab = document.getElementById("admin-batches-tab");
    const adminItemsTab = document.getElementById("admin-items-tab");
    const tabButtons = document.querySelectorAll(".admin-main-tab");

    // Admin batches
    const batchListInfo = document.getElementById("batch-list-info");
    const batchList = document.getElementById("batch-list");
    const batchItemsWrapper = document.getElementById("batch-items-wrapper");
    const selectedBatchLabel = document.getElementById("selected-batch-label");
    const approveBatchBtn = document.getElementById("approve-batch-btn");
    const sendWhatsAppBtn = document.getElementById("send-whatsapp-btn");
    const adminBatchBody = document.getElementById("admin-batch-body");
    const batchSearchNameInput = document.getElementById("batch-search-name");
    const batchSearchDateInput = document.getElementById("batch-search-date");
    const batchSearchBtn = document.getElementById("batch-search-btn");
    const batchClearSearchBtn = document.getElementById("batch-clear-search-btn");
    const batchFilterButtons = document.querySelectorAll(".batch-filter-tab");

    // Admin items
    const countInfo = document.getElementById("count-info");
    const inventoryBody = document.getElementById("inventory-body");
    const itemSearchInput = document.getElementById("item-search-input");
    const itemSearchBtn = document.getElementById("item-search-btn");
    const itemClearSearchBtn = document.getElementById("item-clear-search-btn");
    const itemSearchResult = document.getElementById("item-search-result");

    // ===== UTILS =====
    function setStatus(msg) {
      statusText.textContent = msg.toUpperCase();
    }

    function generateId() {
      const ts = Date.now();
      const rand = Math.random().toString(36).substring(2, 8);
      return `ITEM_${ts}_${rand.toUpperCase()}`;
    }

    function generateBatchId() {
      const ts = Date.now();
      const rand = Math.random().toString(36).substring(2, 8).toUpperCase();
      return `BATCH_${ts}_${rand}`;
    }

    function formatDate(iso) {
      if (!iso) return "-";
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return String(iso).toUpperCase();
      return d.toLocaleString().toUpperCase();
    }

    // WhatsApp message: pure "NAME, QTY, GROUP" per line, no caption
    function buildBatchWhatsAppMessage(batchTimeIso, items) {
      const itemLines = items.map((it) => {
        const parts = [
          (it.name || "").toString().toUpperCase(),
          String(it.quantity ?? ""),
          (it.group || "").toString().toUpperCase()
        ];
        return parts.join(", ");
      });
      return itemLines.join("\n");
    }

    function openWhatsAppForBatch(message) {
      const url = `https://wa.me/${WHATSAPP_PHONE}?text=${encodeURIComponent(message)}`;

      try {
        const win = window.open(url, "_blank");
        if (!win) {
          console.warn("WHATSAPP WINDOW BLOCKED OR NOT OPENED");
          return false;
        }
        return true;
      } catch (err) {
        console.error("FAILED TO OPEN WHATSAPP:", err);
        return false;
      }
    }

    function getBatchKeyForItem(item) {
      return item.batchId || item.batchTime || item.timestamp || "UNKNOWN";
    }

    function getBatchTimeForItem(item) {
      return item.batchTime || item.timestamp || null;
    }

    function getStatusDisplay(statusRaw) {
      const s = (statusRaw || "PENDING").toUpperCase();
      if (s === "APPROVED") return "âœ… APPROVED";
      return "ðŸŸ¡ PENDING";
    }

    function getBatchDisplayNameFromItems(batchKey, items) {
      if (!items || !items.length) return formatDate(batchKey);
      const first = items[0];
      const batchName = (first.batchName || "").trim();
      const batchTime = getBatchTimeForItem(first) || batchKey;
      if (batchName) return batchName;
      return formatDate(batchTime);
    }

    async function getBackendToken() {
      try {
        const res = await fetch(BACKEND_URL, { method: "POST" });
        if (!res.ok) {
          console.warn("BACKEND /get-token HTTP ERROR:", res.status);
          return null;
        }
        const data = await res.json().catch(() => ({}));
        if (!data.token) {
          console.warn("BACKEND /get-token RETURNED NO TOKEN");
          return null;
        }
        return data.token;
      } catch (err) {
        console.error("BACKEND /get-token FAILED:", err);
        return null;
      }
    }

    async function githubRequest(path, options = {}) {
      const token = await getBackendToken();
      if (!token) {
        throw new Error("BACKEND TOKEN REQUEST FAILED");
      }

      const res = await fetch(`https://api.github.com${path}`, {
        ...options,
        headers: {
          "Authorization": `Bearer ${token}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json",
          ...(options.headers || {})
        }
      });

      if (!res.ok) {
        const text = await res.text();
        throw new Error(`GITHUB ERROR ${res.status}: ${text}`);
      }
      return res.json();
    }

    function resetForm() {
      itemNameInput.value = "";
      itemQtyInput.value = "";
      itemGroupInput.value = "";
      itemDetailsInput.value = "";
      batchEditIndex = null;
      adminEditId = null;

      if (currentRole === "admin") {
        submitBtn.textContent = "UPDATE ITEM";
        formTitle.textContent = "EDIT ITEM (ADMIN)";
      } else {
        submitBtn.textContent = "ADD TO BATCH";
        formTitle.textContent = "ADD ITEM";
      }
      cancelEditBtn.style.display = "none";
    }

    function moveStaffUIForRole() {
      if (!staffBatchWrapper || !adminCard || !mainEl || !adminAddContainer) return;
      if (currentRole === "admin") {
        // Move staff UI into admin ADD tab
        if (staffBatchWrapper.parentNode !== adminAddContainer) {
          adminAddContainer.appendChild(staffBatchWrapper);
        }
      } else {
        // Move staff UI back above admin panel
        if (staffBatchWrapper.parentNode !== mainEl) {
          mainEl.insertBefore(staffBatchWrapper, adminCard);
        }
      }
    }

    function setAdminMainTab(tab) {
      tabButtons.forEach((b) => {
        b.classList.toggle("active", b.dataset.tab === tab);
      });
      adminAddTab.style.display = tab === "add" ? "block" : "none";
      adminBatchesTab.style.display = tab === "batches" ? "block" : "none";
      adminItemsTab.style.display = tab === "items" ? "block" : "none";
    }

    function updateRoleUI() {
      moveStaffUIForRole();

      if (currentRole === "admin") {
        roleBadge.textContent = "ADMIN";
        roleBadge.className = "badge badge-admin";
        adminCard.style.display = "block";
        setAdminMainTab("batches");
      } else {
        roleBadge.textContent = "STAFF";
        roleBadge.className = "badge badge-staff";
        adminCard.style.display = "none";
      }
      renderBatch();
      renderAdminViews();
    }

    // Simple "ding" sound when clicking bell (needs user interaction)
    function playBellSound() {
      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const ctx = new AudioContext();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = "sine";
        osc.frequency.value = 880;
        osc.connect(gain);
        gain.connect(ctx.destination);
        gain.gain.value = 0.1;
        const now = ctx.currentTime;
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.6);
        osc.start(now);
        osc.stop(now + 0.6);
      } catch (e) {
        console.warn("Audio not available:", e);
      }
    }

    // ===== LOAD / SAVE INVENTORY =====
    async function loadInventory() {
      try {
        setStatus("LOADING FROM GITHUBâ€¦");
        const data = await githubRequest(
          `/repos/${REPO_OWNER}/${REPO_NAME}/contents/${encodeURIComponent(FILE_PATH)}?ref=${BRANCH}`
        );

        currentSha = data.sha;
        const decoded = atob(data.content.replace(/\n/g, ""));
        inventory = decoded.trim() ? JSON.parse(decoded) : [];

        renderAdminViews();
        setStatus("LOADED");
      } catch (err) {
        console.error("ERROR LOADING INVENTORY:", err);
        inventory = [];
        currentSha = null;
        renderAdminViews();
        setStatus("WORKING OFFLINE (INVENTORY NOT LOADED)");
      }
    }

    async function saveInventory() {
      const content = btoa(JSON.stringify(inventory, null, 2));
      const body = {
        message: "UPDATE INVENTORY.JSON FROM INVENTORY-APP",
        content,
        branch: BRANCH
      };
      if (currentSha) body.sha = currentSha;

      const data = await githubRequest(
        `/repos/${REPO_OWNER}/${REPO_NAME}/contents/${encodeURIComponent(FILE_PATH)}`,
        { method: "PUT", body: JSON.stringify(body) }
      );

      currentSha = data.content.sha;
    }

    // ===== STAFF/ADMIN BATCH UI =====
    function renderBatch() {
      batchBody.innerHTML = "";

      if (!batchItems.length) {
        batchBody.innerHTML =
          '<tr><td colspan="6" class="muted">NO ITEMS IN BATCH.</td></tr>';
      } else {
        batchItems.forEach((item, index) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td>${item.id}</td>
            <td>${item.name}</td>
            <td>${item.quantity}</td>
            <td>${item.group || ""}</td>
            <td>${item.details || ""}</td>
            <td class="actions-cell">
              <button class="small secondary" data-action="edit-batch" data-index="${index}">EDIT</button>
              <button class="small danger" data-action="remove-batch" data-index="${index}">REMOVE</button>
            </td>`;
          batchBody.appendChild(tr);
        });
      }
    }

    batchBody.addEventListener("click", (e) => {
      const btn = e.target;
      if (!btn.dataset.action) return;
      const idx = Number(btn.dataset.index);

      if (btn.dataset.action === "edit-batch") {
        const item = batchItems[idx];
        batchEditIndex = idx;
        itemNameInput.value = item.name;
        itemQtyInput.value = item.quantity;
        itemGroupInput.value = item.group || "";
        itemDetailsInput.value = item.details || "";
        submitBtn.textContent = currentRole === "admin" ? "UPDATE ITEM" : "UPDATE BATCH ITEM";
        cancelEditBtn.style.display = "inline-block";
        formTitle.textContent = currentRole === "admin" ? "EDIT ITEM (ADMIN)" : "EDIT BATCH ITEM";
        window.scrollTo({ top: 0, behavior: "smooth" });
      } else if (btn.dataset.action === "remove-batch") {
        batchItems.splice(idx, 1);
        renderBatch();
      }
    });

    uploadBatchBtn.addEventListener("click", async () => {
      if (!batchItems.length) {
        batchStatus.textContent = "NO ITEMS IN BATCH.";
        return;
      }

      try {
        setStatus("UPLOADING BATCHâ€¦");
        batchStatus.textContent = "UPLOADINGâ€¦";

        const batchTime = new Date().toISOString();
        const batchId = generateBatchId();

        await loadInventory();

        const enriched = batchItems.map((item) => ({
          ...item,
          batchId,
          batchTime,
          batchStatus: "PENDING",
          batchName: item.batchName || ""
        }));

        inventory = inventory.concat(enriched);
        await saveInventory();
        await loadInventory();

        batchItems = [];
        renderBatch();
        batchStatus.textContent =
          "BATCH UPLOADED AT " + formatDate(batchTime);
        setStatus("BATCH UPLOADED");
      } catch (err) {
        console.error("BATCH UPLOAD FAILED:", err);
        batchStatus.textContent = "ERROR UPLOADING BATCH.";
        setStatus("ERROR UPLOADING");
      }
    });

    // ===== ITEM NAME SUGGESTIONS =====
    function clearSuggestions() {
      if (!itemSuggestions) return;
      itemSuggestions.innerHTML = "";
      itemSuggestions.style.display = "none";
    }

    function showItemSuggestions(term) {
      if (!itemSuggestions) return;
      const query = term.trim().toUpperCase();
      if (!query) {
        clearSuggestions();
        return;
      }

      const byName = new Map();
      inventory.forEach((it) => {
        const n = (it.name || "").toString().toUpperCase();
        if (!n) return;
        if (!byName.has(n)) byName.set(n, it);
      });

      const matches = [];
      byName.forEach((it, n) => {
        if (n.includes(query)) matches.push(it);
      });

      matches.sort((a, b) => {
        const na = (a.name || "").toString();
        const nb = (b.name || "").toString();
        return na.localeCompare(nb);
      });

      if (!matches.length) {
        clearSuggestions();
        return;
      }

      const limited = matches.slice(0, 8);
      itemSuggestions.innerHTML = "";
      limited.forEach((it) => {
        const div = document.createElement("div");
        div.className = "suggestion-item";
        div.dataset.name = (it.name || "").toString().toUpperCase();
        div.textContent = it.name || "";
        itemSuggestions.appendChild(div);
      });
      itemSuggestions.style.display = "block";
    }

    itemNameInput.addEventListener("input", () => {
      showItemSuggestions(itemNameInput.value);
    });

    itemSuggestions.addEventListener("click", (e) => {
      const target = e.target.closest(".suggestion-item");
      if (!target) return;
      const nameUpper = target.dataset.name || "";
      const match = inventory.find(
        (it) => (it.name || "").toString().toUpperCase() === nameUpper
      );
      if (!match) return;

      itemNameInput.value = (match.name || "").toString().toUpperCase();
      if (match.quantity != null) itemQtyInput.value = match.quantity;
      itemGroupInput.value = (match.group || "").toString().toUpperCase();
      itemDetailsInput.value = (match.details || "").toString().toUpperCase();
      clearSuggestions();
    });

    document.addEventListener("click", (e) => {
      if (nameInputWrapper && !nameInputWrapper.contains(e.target)) {
        clearSuggestions();
      }
    });

    // ===== ADMIN: GROUPING =====
    function groupByBatch() {
      const groups = {};
      inventory.forEach((item) => {
        const key = getBatchKeyForItem(item);
        if (!groups[key]) groups[key] = [];
        groups[key].push(item);
      });
      return groups;
    }

    // ===== ADMIN: RENDER VIEWS =====
    function renderAdminViews() {
      if (currentRole !== "admin") return;

      const groups = groupByBatch();
      const keys = Object.keys(groups).sort((a, b) => {
        const ia = groups[a][0];
        const ib = groups[b][0];
        const ta = getBatchTimeForItem(ia) || "";
        const tb = getBatchTimeForItem(ib) || "";
        const da = new Date(ta);
        const db = new Date(tb);
        if (isNaN(da) || isNaN(db)) return 0;
        return db - da;
      });

      // Count pending / approved batches
      let pendingCount = 0;
      let approvedCount = 0;
      keys.forEach((k) => {
        const first = groups[k][0];
        const statusRaw = (first.batchStatus || "PENDING").toUpperCase();
        if (statusRaw === "APPROVED") approvedCount++;
        else pendingCount++;
      });

      if (pendingBadge) {
        pendingBadge.textContent = `ðŸ”” ${pendingCount}`;
        if (pendingCount > 0) {
          pendingBadge.classList.add("bell-alert");
        } else {
          pendingBadge.classList.remove("bell-alert");
        }
      }

      // BATCH LIST TAB
      batchList.innerHTML = "";
      let shownCount = 0;

      keys.forEach((k) => {
        const items = groups[k];
        const first = items[0];
        const batchTime = getBatchTimeForItem(first) || k;
        const batchName = (first.batchName || "").trim();
        const displayName = batchName || formatDate(batchTime);
        const statusRaw = (first.batchStatus || "PENDING").toUpperCase();
        const statusDisplay = getStatusDisplay(statusRaw);

        // Filter by pending/approved tab
        if (currentBatchFilter === "pending" && statusRaw === "APPROVED") return;
        if (currentBatchFilter === "approved" && statusRaw !== "APPROVED") return;

        // Filter by search
        const nameFilter = batchSearchName;
        const dateFilter = batchSearchDate;
        const dateStr = (() => {
          const d = new Date(batchTime);
          if (isNaN(d)) return "";
          return d.toISOString().slice(0, 10);
        })();

        if (nameFilter && !displayName.toUpperCase().includes(nameFilter)) {
          return;
        }
        if (dateFilter && dateStr !== dateFilter) {
          return;
        }

        const div = document.createElement("div");
        div.className = "batch-header";
        div.innerHTML = `
          <span>BATCH: ${displayName}</span>
          <span>DATE: ${formatDate(batchTime)}</span>
          <span>ITEMS: ${items.length}</span>
          <span>STATUS: ${statusDisplay}</span>
          <span>
            <button class="small secondary" data-action="view-batch" data-key="${k}">VIEW</button>
            <button class="small secondary" data-action="rename-batch" data-key="${k}">RENAME</button>
          </span>`;
        batchList.appendChild(div);
        shownCount++;
      });

      if (!keys.length) {
        batchListInfo.textContent = "NO BATCHES FOUND.";
      } else {
        batchListInfo.textContent = `${pendingCount} PENDING â€¢ ${approvedCount} APPROVED (VIEW: ${currentBatchFilter.toUpperCase()}, SHOWING ${shownCount})`;
      }

      // ALL ITEMS TAB
      inventoryBody.innerHTML = "";
      if (!inventory.length) {
        countInfo.textContent = "NO ITEMS IN INVENTORY.";
        inventoryBody.innerHTML =
          '<tr><td colspan="8" class="muted">NO ITEMS.</td></tr>';
        itemSearchResult.textContent = "";
      } else {
        countInfo.textContent = `${inventory.length} ITEMS`;

        let matchCount = 0;
        let firstMatchInfo = null;

        inventory.forEach((item) => {
          const nameStr = (item.name || "").toString().toUpperCase();
          const matches = itemSearchTerm && nameStr.includes(itemSearchTerm);

          if (matches) {
            matchCount++;
            if (!firstMatchInfo) {
              const batchKey = getBatchKeyForItem(item);
              const batchTime = getBatchTimeForItem(item) || batchKey;
              const batchLabel = (item.batchName && item.batchName.trim())
                ? item.batchName
                : formatDate(batchTime);
              const statusRaw = item.batchStatus || "PENDING";
              const statusDisplay = getStatusDisplay(statusRaw);
              firstMatchInfo = {
                name: item.name,
                batchLabel,
                statusDisplay
              };
            }
          }

          const tr = document.createElement("tr");
          if (matches) {
            tr.classList.add("highlight-row");
          }
          tr.innerHTML = `
            <td>${item.id || "-"}</td>
            <td>${item.name || ""}</td>
            <td>${item.quantity ?? ""}</td>
            <td>${item.group || ""}</td>
            <td>${item.details || ""}</td>
            <td>${formatDate(item.batchTime || item.timestamp)}</td>
            <td>${formatDate(item.updatedAt || item.timestamp)}</td>
            <td class="actions-cell">
              <button class="small secondary" data-action="edit-item" data-id="${item.id}">EDIT</button>
              <button class="small danger" data-action="delete-item" data-id="${item.id}">DELETE</button>
            </td>`;
          inventoryBody.appendChild(tr);
        });

        if (itemSearchTerm && matchCount > 0 && firstMatchInfo) {
          itemSearchResult.textContent =
            `'${firstMatchInfo.name}' FOUND IN BATCH: ${firstMatchInfo.batchLabel} â€¢ STATUS: ${firstMatchInfo.statusDisplay}`;
        } else if (itemSearchTerm) {
          itemSearchResult.textContent = "NO ITEMS FOUND FOR SEARCH.";
        } else {
          itemSearchResult.textContent = "";
        }
      }

      // Selected batch details (if any)
      if (selectedBatchKey && groups[selectedBatchKey]) {
        renderSelectedBatchItems(selectedBatchKey, groups[selectedBatchKey]);
      } else {
        batchItemsWrapper.style.display = "none";
        selectedBatchLabel.textContent = "NO BATCH SELECTED.";
      }
    }

    // BATCH LIST CLICK (VIEW / RENAME)
    batchList.addEventListener("click", async (e) => {
      const btn = e.target;
      const action = btn.dataset.action;
      const key = btn.dataset.key;
      if (!action || !key) return;

      const groups = groupByBatch();

      if (action === "view-batch") {
        if (!groups[key]) return;
        selectedBatchKey = key;
        renderSelectedBatchItems(key, groups[key]);
      } else if (action === "rename-batch") {
        if (!groups[key]) return;
        const items = groups[key];
        const currentName = (items[0].batchName || "").trim();
        const newName = prompt("ENTER BATCH NAME:", currentName);
        if (newName === null) return;

        const trimmed = newName.trim().toUpperCase();
        try {
          setStatus("UPDATING BATCH NAMEâ€¦");
          await loadInventory();
          const freshGroups = groupByBatch();
          const freshItems = freshGroups[key] || [];
          freshItems.forEach((it) => {
            it.batchName = trimmed;
          });
          await saveInventory();
          await loadInventory();
          setStatus("BATCH NAME UPDATED");
        } catch (err) {
          console.error("RENAME BATCH FAILED:", err);
          setStatus("ERROR RENAMING BATCH");
        }
      }
    });

    function renderSelectedBatchItems(batchKey, items) {
      batchItemsWrapper.style.display = "block";
      const first = items[0];
      const batchTime = getBatchTimeForItem(first) || batchKey;
      const batchName = (first.batchName || "").trim();
      const displayName = batchName || formatDate(batchTime);
      const statusRaw = first.batchStatus || "PENDING";
      const statusDisplay = getStatusDisplay(statusRaw);

      selectedBatchLabel.textContent = `BATCH: ${displayName} â€¢ DATE: ${formatDate(
        batchTime
      )} â€¢ ${items.length} ITEM(S) â€¢ STATUS: ${statusDisplay}`;

      adminBatchBody.innerHTML = "";
      items.forEach((item) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${item.id || "-"}</td>
          <td>${item.name || ""}</td>
          <td>${item.quantity ?? ""}</td>
          <td>${item.group || ""}</td>
          <td>${item.details || ""}</td>
          <td>${formatDate(item.updatedAt || item.timestamp)}</td>
          <td class="actions-cell">
            <button class="small secondary" data-action="edit-item" data-id="${item.id}">EDIT</button>
            <button class="small danger" data-action="delete-item" data-id="${item.id}">DELETE</button>
          </td>`;
        adminBatchBody.appendChild(tr);
      });
    }

    // APPROVE (ADMIN ONLY)
    approveBatchBtn.addEventListener("click", async () => {
      if (!selectedBatchKey) {
        alert("NO BATCH SELECTED.");
        return;
      }

      const groups = groupByBatch();
      const items = groups[selectedBatchKey];
      if (!items || !items.length) {
        alert("BATCH HAS NO ITEMS.");
        return;
      }

      try {
        setStatus("APPROVING BATCHâ€¦");

        inventory.forEach((it) => {
          if (getBatchKeyForItem(it) === selectedBatchKey) it.batchStatus = "APPROVED";
        });
        await saveInventory();
        await loadInventory();

        const freshGroups = groupByBatch();
        const freshItems = freshGroups[selectedBatchKey] || [];
        const payload = {
          phone: ADMIN_PHONE,
          batchTime: getBatchTimeForItem(freshItems[0]) || selectedBatchKey,
          items: freshItems.map((it) => ({
            name: it.name,
            quantity: it.quantity,
            group: it.group,
            details: it.details
          }))
        };

        fetch(NOTIFY_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        }).catch((err) => console.error("NOTIFY FAILED:", err));

        setStatus("BATCH APPROVED");
      } catch (err) {
        console.error("APPROVE FAILED:", err);
        setStatus("ERROR APPROVING BATCH");
      }
    });

    // SEND WHATSAPP (ADMIN ONLY, AFTER APPROVAL)
    sendWhatsAppBtn.addEventListener("click", () => {
      if (!selectedBatchKey) {
        alert("NO BATCH SELECTED.");
        return;
      }

      const groups = groupByBatch();
      const items = groups[selectedBatchKey];
      if (!items || !items.length) {
        alert("BATCH HAS NO ITEMS.");
        return;
      }

      const first = items[0];
      const statusRaw = (first.batchStatus || "PENDING").toUpperCase();
      if (statusRaw !== "APPROVED") {
        alert("BATCH IS NOT APPROVED YET.");
        return;
      }

      const batchTime = getBatchTimeForItem(first) || selectedBatchKey;
      const message = buildBatchWhatsAppMessage(batchTime, items);
      const opened = openWhatsAppForBatch(message);
      if (!opened) {
        alert("WHATSAPP MESSAGE (COPY & SEND):\n\n" + message);
      }
    });

    // ADMIN TABLE ACTIONS (EDIT / DELETE)
    adminBatchBody.addEventListener("click", handleAdminTableClick);
    inventoryBody.addEventListener("click", handleAdminTableClick);

    async function handleAdminTableClick(e) {
      const btn = e.target;
      const id = btn.dataset.id;
      if (!btn.dataset.action || !id) return;

      if (btn.dataset.action === "edit-item") {
        const item = inventory.find((it) => it.id === id);
        if (!item) {
          setStatus("ITEM NOT FOUND");
          return;
        }

        currentRole = "admin";
        updateRoleUI();

        adminEditId = id;
        itemNameInput.value = (item.name || "").toString().toUpperCase();
        itemQtyInput.value = item.quantity ?? "";
        itemGroupInput.value = (item.group || "").toString().toUpperCase();
        itemDetailsInput.value = (item.details || "").toString().toUpperCase();
        submitBtn.textContent = "UPDATE ITEM";
        cancelEditBtn.style.display = "inline-block";
        formTitle.textContent = "EDIT ITEM (ADMIN)";
        window.scrollTo({ top: 0, behavior: "smooth" });
      } else if (btn.dataset.action === "delete-item") {
        if (!confirm("DELETE THIS ITEM?")) return;

        try {
          setStatus("DELETING ITEMâ€¦");
          await loadInventory();

          const idx = inventory.findIndex((it) => it.id === id);
          if (idx === -1) {
            setStatus("ITEM NOT FOUND");
            return;
          }

          inventory.splice(idx, 1);
          await saveInventory();
          await loadInventory();
          setStatus("ITEM DELETED");
        } catch (err) {
          console.error("DELETE FAILED:", err);
          setStatus("ERROR DELETING");
        }
      }
    }

    // STAFF/ADMIN FORM SUBMIT
    itemForm.addEventListener("submit", async (e) => {
      e.preventDefault();

      const name = itemNameInput.value.trim().toUpperCase();
      const qty = Number(itemQtyInput.value || 0);
      const group = itemGroupInput.value.trim().toUpperCase();
      const details = itemDetailsInput.value.trim().toUpperCase();

      if (!name || Number.isNaN(qty)) {
        alert("NAME AND QUANTITY ARE REQUIRED.");
        return;
      }

      const now = new Date().toISOString();

      // Both staff and admin use same batch mechanism here
      const baseItem = {
        id:
          batchEditIndex === null
            ? generateId()
            : batchItems[batchEditIndex].id,
        name,
        quantity: qty,
        group,
        details,
        timestamp:
          batchEditIndex === null
            ? now
            : batchItems[batchEditIndex].timestamp || now,
        updatedAt: now
      };

      if (batchEditIndex === null) {
        batchItems.push(baseItem);
        setStatus("ITEM ADDED TO BATCH");
      } else {
        batchItems[batchEditIndex] = baseItem;
        setStatus("BATCH ITEM UPDATED");
      }

      renderBatch();
      resetForm();
    });

    cancelEditBtn.addEventListener("click", () => resetForm());

    // ADMIN LOGIN VIA TITLE
    appTitle.addEventListener("click", () => {
      if (currentRole === "admin") {
        currentRole = "staff";
        resetForm();
        updateRoleUI();
        return;
      }

      const pwd = prompt("ENTER ADMIN PASSWORD:");
      if (!pwd) return;
      if (pwd !== ADMIN_PASSWORD) {
        alert("WRONG PASSWORD.");
        return;
      }

      currentRole = "admin";
      updateRoleUI();
      loadInventory();
    });

    // ADMIN MAIN TABS (ADD / BATCHES / ITEMS)
    tabButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        setAdminMainTab(btn.dataset.tab);
      });
    });

    // BATCH PENDING / APPROVED FILTER TABS
    batchFilterButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        currentBatchFilter = btn.dataset.batchView || "pending";
        batchFilterButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        renderAdminViews();
      });
    });

    // BATCH SEARCH EVENTS
    batchSearchBtn.addEventListener("click", () => {
      batchSearchName = (batchSearchNameInput.value || "").trim().toUpperCase();
      batchSearchDate = batchSearchDateInput.value || "";
      renderAdminViews();
    });

    batchClearSearchBtn.addEventListener("click", () => {
      batchSearchNameInput.value = "";
      batchSearchDateInput.value = "";
      batchSearchName = "";
      batchSearchDate = "";
      renderAdminViews();
    });

    // ITEM SEARCH EVENTS
    itemSearchBtn.addEventListener("click", () => {
      itemSearchTerm = (itemSearchInput.value || "").trim().toUpperCase();
      renderAdminViews();
    });

    itemClearSearchBtn.addEventListener("click", () => {
      itemSearchInput.value = "";
      itemSearchTerm = "";
      itemSearchResult.textContent = "";
      renderAdminViews();
    });

    // BELL CLICK: go to batches â†’ pending + ding + scroll
    pendingBadge.addEventListener("click", () => {
      if (currentRole !== "admin") return;
      setAdminMainTab("batches");
      currentBatchFilter = "pending";
      batchFilterButtons.forEach((b) => {
        b.classList.toggle("active", b.dataset.batchView === "pending");
      });
      renderAdminViews();
      adminCard.scrollIntoView({ behavior: "smooth" });
      playBellSound();
    });

    // INIT
    (async function init() {
      updateRoleUI();
      renderBatch();
      await loadInventory();
    })();
  </script>
</body>
</html>
